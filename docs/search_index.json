[
["index.html", "Introducción a R para Ciencias Sociales. Aplicación practica en la EPH Capítulo 1 Introducción 1.1 Presentación 1.2 Objetivos del curso 1.3 Clases y contenido 1.4 Librerias a instalar", " Introducción a R para Ciencias Sociales. Aplicación practica en la EPH Pablo Tiscornia - Guido Weksler - Diego Kozlowski - Natsumi Shokida. Capítulo 1 Introducción 1.1 Presentación En los últimos años se han difundido muchas herramientas estadísticas novedosas para el análisis de información socioeconómica. En particular el software denominado “R”, por tratarse de un software libre, se extiende cada vez más en diferentes disciplinas y recibe el aporte de investigadores e investigadoras en todo el mundo, multiplicando sistemáticamente sus capacidades. Este programa se destaca, entre varias cosas, por su capacidad de trabajar con grandes volúmenes de información, utilizar múltiples bases de datos en simultáneo, generar reportes, realizar gráficos a nivel de publicación y por su comunidad de usuarios y usuarias que publican sus sintaxis y comparten sus problemas, hecho que potencia la capacidad de consulta y de crecimiento. A su vez, la expresividad del lenguaje permite diseñar funciones específicas que permiten optimizar de forma personalizada el trabajo cotidiano con R. 1.2 Objetivos del curso El presente Taller tiene como objetivo principal introducirse en el aprendizaje del lenguaje de programación “R” aplicado procesamiento de la Encuesta Permanente de Hogares (EPH) - INDEC. Se apunta a brindar a los y las participantes herramientas prácticas para el procesamiento de datos haciendo énfasis en la producción y el análisis de estadísticas socioeconómicas en pos de abrir puertas para realizar investigaciones propias sobre diversas temáticas relacionadas al mercado de trabajo y las condiciones de vida de la población. La Encuesta Permanente de Hogares será la base de datos de aplicación elegida para el curso, dado que representa un insumo fundamental para realizar estudios sobre el mercado de trabajo y las condiciones de vida de la población. Se hará una introducción a los lineamientos conceptuales principales de la encuesta, en pos de que los y las participantes puedan abordar con datos distintas problemáticas vinculadas al mercado de trabajo y las condiciones de vida de la población. 1.3 Clases y contenido Clase 1 - Conceptos Principales de EPH. Temas de clase: Presentación del curso. Presentación de la Encuesta Permanente de Hogares: Lineamientos conceptuales y metodología Abordaje del marco teórico y analítico de la EPH y sus aplicaciones prácticas. Síntesis del operativo de campo, cobertura y periodicidad de la Encuesta Definiciones de las principales variables de interés a abordar en el curso: Condición de actividad, categoría ocupacional, precariedad y pobreza Metodología usuaria de las Bases de microdatos. Utilización del Diseño de Registro. Clase 2 – Introduciendo a R. Temas de clase: Descripción del programa “R”. Lógica sintáctica del lenguaje y comandos básicos Presentación de la plataforma RStudio para trabajar en “R” Caracteres especiales en “R” Operadores lógicos y aritméticos Definición de Objetos: Valores, Vectores y DataFrames Tipos de variable (numérica, de caracteres, lógicas) Lectura y Escritura de Archivos Clase 3 – Trabajando con bases de datos y Mercado de Trabajo. Temas de clase: Limpieza de Base de datos: Renombrar y recodificar variables, tratamiento de valores faltantes (missing values/ NA´s) Seleccionar variables, ordenar y agrupar la base de datos para realizar cálculos Creación de nuevas variables Aplicar filtros sobre la base de datos Construir medidas de resumen de la información Tratamiento de variables numéricas (edad, ingresos, horas de trabajo, cantidad de hijos / componentes del hogar, entre otras). Ejercicios prácticos para aplicar lo expuesto: Replicar Informe Técnico de Mercado de Trabajo (EPH-INDEC) Cálculo de tasas básicas del mercado de trabajo (tasa de actividad, empleo, desempleo, entre otras) Cálculo de tasas para distintos subconjuntos poblacionales (por aglomerado, sexo, grupos de edad) Clase 4: Cálculo de tasas de Pobreza e Indigencia. Temas de clase: Definición de la Canasta Básica Alimentaria y Canasta Básica Total Metodología del cálculo de pobreza por línea (para personas y hogares) Ejercicio de estimación de tasas de Pobreza e Indigencia Ejercicio de estimación de tasas de Pobreza e Indigencia para subgrupos poblacionales (Género, Edad, Regiones) Clase 5 - Variables de ingresos y gráficos. Temas de clase: Procesamiento de indicadores agregados sobre las variables de ingresos (Ingresos laborales, no laborales, de ocupación principal, total familiar) Gráficos básicos de R (función “plot”): Comandos para la visualización ágil de la información Gráficos elaborados en R (función “ggplot”): Gráficos de línea, barras, Boxplots y distribuciones de densidad Parámetros de los gráficos: Leyendas, ejes, títulos, notas, colores Gráficos con múltiples cruces de variables. Clase 6: Pool de Datos en Panel. Gráficos y Matrices de Transición. Temas de clase: Metodología de trabajos en panel con EPH: (Esquema de rotación de la EPH, Variables para la identificación de los individuos en distintos períodos, Consistencias) Proceso para la construcción de paneles en R. Cálculo de Frecuencias de transiciones de estados (Categorías Ocupacionales, Situaciones de Pobreza/Indigencia) Gráficos de Transición de estados Clase 7: Documentación en R. Generación de reportes/informes. Temas de clase: Manejo de las extensiones del software “Rmarkdown” y “RNotebook” para elaborar documentos de trabajo, presentaciones interactivas e informes: Opciones para mostrar u ocultar código en los reportes Definición de tamaño, títulos y formato con el cual se despliegan los gráficos y tablas en el informe Caracteres especiales para incluir múltiples recursos en el texto del informe: Links a páginas web, notas al pie, enumeraciones, cambios en el formato de letra (tamaño, negrita, cursiva) Código embebido en el texto para automatización de reportes Clase 8: Introducción a R Intermedio Temas de clase: Acercamiento a técnicas más sofisticadas en R, útiles para automatizar el procesamiento periódico de la información: Estructuras de código condicionales Loops Creación de funciones a medida del usuario Herramientas para continuar el aprendizaje en R: Foros reconocidos de usuarios de R. Comunidades donde se comparten conocimientos, experiencias, consultas. Comandos para acceder a los documentos de ayuda. Clase 9: Trabajos prácticos: R en concreto / examen Se presentará a los/as alumnos/as problemas concretos vinculados a la EPH y en relación a las experiencias que se fueron volcando a lo largo de la cursada. Se deberán abordar mediante el uso de R, aplicando lo aprendido en los módulos anteriores. En conjunto se expondrán los desafíos que emergen en el momento y la evaluación de las herramientas adecuadas para su abordaje y resolución. Entre los temas giran aquellos vinculados a la distribución personal del ingreso/Construcción de percentiles de ingreso; el mercado laboral a través de la herramienta Panel de datos; la documentación en R (Estilo de Notas de Clase). Espacio para consultas puntuales sobre los temas vistos durante el curso y presentación del trabajo final a entregar. 1.4 Librerias a instalar install.packages(c(&quot;tidyverse&quot;,&quot;openxlsx&quot;,&#39;ggplot2&#39;,&#39;ggthemes&#39;, &#39;ggrepel&#39;,&#39;ggalt&#39;,&#39;kableExtra&#39;,&#39;GGally&#39;,&#39;ggridges&#39;,&#39;fs&#39;,&#39;purrr&#39;,&#39;rmarkdown&#39;)) "],
["conceptos-principales-de-eph.html", "Capítulo 2 Conceptos Principales de EPH 2.1 ¿Qué es la EPH? 2.2 Traduzcamos 2.3 Características de la EPH 2.4 La Muestra 2.5 Instrumento de medición: El medio hacia la operacionalización de los objetivos 2.6 Tres cuestionarios 2.7 Marco analítico y temático de la EPH 2.8 Cuestinario individual: Principales indicadores 2.9 Caracterización de la población ocupada", " Capítulo 2 Conceptos Principales de EPH 2.1 ¿Qué es la EPH? 2.2 Traduzcamos 2.2.1 Objetivos de la EPH El objetivo general de la encuesta es el conocimiento de un aspecto de nuestra realidad: La inserción de la población en la estructura económico-social1. .footnote[ [1] La nueva Encuesta Permanente deHogares de Argentina. 2003] Dicha inserción puede ser analizada a partir de tres ejes: Características demográficas. Inserción en la producción de bienes y servicios. Participación en la distribución del producto social. 2.3 Características de la EPH Orígen: La encuesta nace en 1973 con la modalidad de relevamiento “puntual”: 2 ondas por año, en mayo y octubre. Cambios: En 2003 se lleva adelante la reformulación de la encuesta: pasa a ser un relevamiento contínuo y trimestral, relevandose 4 veces al año. Esquema: centralización normativa (equipo central) - descentralización ejecutvia (equipos provinciales). Cobertura o dominio de estimación: Principales aglomerados urbanos. Fue creciendo progresivamente desde la puntual hacia la continua, hasta llega a 31 aglomerados urbanos (todas las capitales de provincia + aquellos aglomerados con +100.000 habitantes). Concepto de aglomerado: En las encuestas de fuerza de trabajo dos localidades distintas, pero próximas y que conforman en realidad un único mercado de trabajo, son tomadas como un único aglomerado.2 .footnote[ [2] EPH. Actualización del diseño de sus muestras 1974-2003] La encuesta representa al 72% del total urbano (En Arg. según el censo 2010 la población urbana llegaba al 90%) Que es el 62% del total pais Una vez al año se aplica al total urbano (EAHU). Proyecto en etapa de pruebas: cobertura del ámbito rural/urbano-rural (extensión al total país). 2.4 La Muestra La Encuesta Permanente de Hogares es una encueta por muestreo: relevo a un “pequeño” puñado de hogares que representan al conjunto de la población. Diseño Muestral: bietápica estratificada. Tener en cuenta: La representatividad El margen de error Coeficientes de variación de los estimadores Límite superior/inferior de la estimación puntual Esquema de rotación: 2-2-2 (la vivienda entra dos trimestres consecutivos - descansa dos trimestres consecutivos - vuelve a la muestra dos trimestres consecutivos) 2.4.1 Principales temáticas abordadas por la EPH Características demográficas básicas Características ocupacionales Características migratorias Características habitacionales Características educacionales Características de ingreso 2.5 Instrumento de medición: El medio hacia la operacionalización de los objetivos Operacionalizar: pasar de conceptos teóricos y abstractos a indicadores concretos y medibles. Recordar conceptos: Confiabilidad (que el instrumento mida lo mismo sobre el mismo fenómeno a lo largo del tiempo) Validez (¿medimos lo que decimos que queremos medir?) 2.6 Tres cuestionarios 2.6.1 Cuestionario de vivienda Definición: “cualquier recinto fijo o móvil que ha sido construído o adaptado para alojar personas. Las viviendas pueden ser particulares o colectivas. La EPH sólo encuesta las particulares”. Principales dimensiones que aborda el cuestionario de vivienda: * Identificación de viviendas y hogares * Características de la vivienda y hábitat * Condición de residencia 2.6.2 Cuestionario de hogar Definición: “Persona o grupo de personas parientes o no, que viven bajo un mismo techo y comparten los gastos de alimentación” Principales dimensiones: + Características habitacionales + Caracetrísticas demográficas básicas (Sexo, edad, relación de parentesco) + Características educacionales (alfabetización, nivel educativo) + Condición de migración (país de nacimiento, de residencia en los últimos 5 años) + Cobertura de salud + División social del trabajo doméstico en el hogar + Presencia de discapacitados en el hogar + Estrategias y fuentes de manutención de los hogares + Ingresos monetarios no laborales 2.6.2.1 El jefe o la jefa de hogar Definición: Aquella persona reconocida como tal por los demás miembros del hogar. - No es estático. Responde tanto a un modelo general de asignación social y sexual de roles al interior del hogar como a criterios operativos: + económicos (quien trabaja / quien más cobra) + antigüedad + horarios (a quien se encuentra en el hogar) En caso de no haber acuerdo entre los miembros del hogar acerca de quién es el jefe o la jefa, se asigna por el o la encuestadora según los siguientes criterios (en orden de prioridad): 1. Quien tiene a su cargo la responsabilidad económica del hogar 1. El miembro más antiguo del hogar 1. Quien haya acudido al llamado 2.7 Marco analítico y temático de la EPH 2.7.1 Cuestionario de individuos Aplicación: Todas aquellas personas residentes del hogar mayores de 10 años (niñosy niñas en edad escolar vs en edad de trabajar, en Argentina y otros países). Respondentes Mayor de 18 años (Puede ser auto o no auto-respondente) Mide el principal concepto: El Trabajo: Definiión de la 19° Conferencia Internacional del Trabajo - OIT (CIET, 2013): Todas las actividades desarrolladas en unidades económicas por personas de cualquier sexo con el fin de producir bienes y servicios para el consumo de terceros o autoconsumo. EPH: Es toda actividad destinada a la producción de bienes y servicios con valor económico en el mercado (trabajo en la ocupación) La EPH toma una definición acotada del concepto de trabajo, acorde a sus objetivos y a sus instrumentos. No puede perder la capacidad de medir. Entonces, ¿según la EPH, a quienes se los considera “trabajando”? ¿Si realiza actividades laborales pagas en dinero o especie (en relación de dependencia, changas, trabajos temporarios, etc.)? SÍ ¿Si rrealiza actividades para su propio consumo? NO ¿Si realiza una contraprestación laboral en virtud de la recepción de un subsidio o plan social? SÍ Si es trabajador o trabajadora por cuenta propia con instalaciones (taller, negocio u oficina) y concurrió a su lugar de trabajo aunque no tuvo clientes? SÍ ¿Si realiza actividades domésticas en su hogar (por ej. Ama de casa)? NO ¿Si realiza actividades voluntarias? NO ¿Si realiza actividades laborales no remuneradas (por ej. docentes ad-honorem, pasantes)? SÍ 2.8 Cuestinario individual: Principales indicadores Condición de actividad: relación de las personas con la producción de bienes y servicios con valor económico en el mercado. Categorías de la variable: Ocupado u ocupada (quienes se encuentran trabajando en la semana de referencia o no trabajando pero manteniendo un puesto de trabajo -suspensiones-) Desocupado o desocupada (quienes no tienen trabajo, están disponibles para trabajar y buscan trabajo activamente en algún momento de los últimos 30 días) Inactivo o inactiva (quienes no se encuentran trabajando ni buscaron activamente trabajo en el período de referencia -últimos 30 días-) Población económicamente activa: Aquellas personas que tienen una ocupación o que sin tenerla la están buscando activamente (población ocupada + desocupada) 2.9 Caracterización de la población ocupada Pluriempleo Subocupación y sobreocupación -horaria- Demanda de empleo Categoría ocupacional: En cuanto a la posición que tienen las personas respecto al esquema de relaciones sociales de producción, de un sistema de producción histórico y vigente (el capitalismo), los individuos se pueden clasificarse en: Patrones Cuenta propia Asalariados Trabajadores familiares 2.9.1 Otros indicadores para describir a la población ocupada Intencidad en la inserción (subempleo) Búsqueda de otra ocupación (y sus causas) Tamaño del establecimiento Antigüedad en el puesto de trabajo / Continuidad laboral Calidad del empleo Utilización de capital (propio / ajeno) Movimientos interurbanos 2.9.2 Caracterízación de la población desocupada Tiempo de búsqueda Razones por las que no encuentra trabajo Temporalidad en la desocupación (nuevo desocupado / Viejo desocupado) Características de la última ocupación 2.9.3 Clasificadores utilizados en la EPH (Rama de actividad y Tarea / Ocupación) Actividad (rama): Clasificador de Actividades para Encuestas Sociodemográficas (CAES-MERCOSUR) Ocupación: Clasificador Nacional de Ocupaciones (CNO-2001-INDEC) Códigos geográficos: Países y provincias Acceso a materiales de la Encuesta: Diseño de registro a agosto de 2019 Cuestionario individual Cuestionario Hogar Cuestionario vivienda La nueva EPH contínua Consideraciones sobre la revisión, evaluación y recuperación de la EPH. Nota metodológica actualizada para el uso de los datos del primer trimestre de 2019 Informe de mercado de trabajo a 1er trimestre de 2019 Sistema de consulta a los cuadros regulares de la EPH contínua Cartografía de la EPH class: middle, center, inverse ## Ejercicios Identificar en los cuestionarios de vivienda, de hogar e individual las preguntas que dan cuenta de las áreas temáticas abordadas por la eph. Identificar, a su vez, qué preguntas dan cuenta de las temáticas del mercado de trabajo (tipo de inserción) y cuáles vinculadas al circuito de satisfacción de necesidades. class: center, middle, inverse Gracias! "],
["introduccion-a-r.html", "Capítulo 3 Introducción a R 3.1 Lógica sintáctica.", " Capítulo 3 Introducción a R https://cran.r-project.org/ 3.0.1 ¿Que es R? Lenguaje para el procesamiento y análisis estadístico de datos Software Libre Sintaxis Básica: R base Sintaxis incremental1: El lenguaje se va ampliando por aportes de Universidades, investigadores/as, usuarios/as y empresas privadas, organizados en librerías (o paquetes) Comunidad web muy grande para realizar preguntas y despejar dudas. Graficos con calidad de publicación fuente: https://gist.github.com/daroczig/3cf06d6db4be2bbe3368 https://www.rstudio.com/ El entorno más cómodo para utilizar el lenguaje R es el programa R studio Rstudio es una empresa que produce productos asociados al lenguaje R, como el programa sobre el que corremos los comandos, y extensiones del lenguaje (librerías). El programa es gratuito y se puede bajar de la página oficial Pantalla Rstudio 3.0.2 Diferencias con STATA y SPSS Gratuito Funciona principalmente por líneas de código (Aunque ya hay paquetes que permiten ejecutar comandos desde el menú y los botones sin tener que esribir código) Trabaja las bases de microdatos de forma virtual y no fisica, lo que permite disponer de varias al mismo tiempo sin mayor dificultad (no requiere abrir cada base, trabajarla por separado y luego cerrarla), ni exije guardar fisicamente los cambios. Más potente Totalmente automatizable Aportes de usuarias y usuarios Extensible a otros lenguajes y usos (presentación como esta, diseño de aplicaciones) Más veloz: fuente: https://github.com/matthieugomez/benchmark-stata-r/blob/master/output/1e7.png 3.1 Lógica sintáctica. 3.1.1 Definición de objetos Los Objetos/Elementos constituyen la categoría escencial del R. De hecho, todo en R es un objeto, y se almacena con un nombre específico que no debe poseer espacios. Un número, un vector, una función, la progresión de letras del abecedario, una base de datos, un gráfico, constituyen para R objetos de distinto tipo. Los objetos que vamos creando a medida que trabajamos pueden visualizarse en la panel derecho superior de la pantalla. El operador &lt;- sirve para definir un objeto. A la izquierda del &lt;- debe ubicarse el nombre que tomará el elemento a crear. Del lado derecho debe ir la definición del mismo A &lt;- 1 Al definir un elemento, el mismo queda guardado en el ambiente del programa, y podrá ser utilizado posteriormente para observar su contenido o para realizar una operación con el mismo A ## [1] 1 A+6 ## [1] 7 Al correr una linea con el nombre del objeto, la consola del programa nos muestra su contenido. Entre Corchetes Observamos el número de orden del elemento en cuestión El operador = es equivalente a &lt;-, pero en la práctica no se utiliza para la definición de objetos. B = 2 B ## [1] 2 &lt;- es un operador Unidireccional, es decir que: A &lt;- B implica que A va tomar como valor el contenido del objeto B, y no al revés. A &lt;- B A #Ahora A toma el valor de B, y B continua conservando el mismo valor ## [1] 2 B ## [1] 2 3.1.2 R base Con R base nos referimos a los comandos básicos que vienen incorporados en el R, sin necesidad de cargar librerías. 3.1.2.1 Operadores lógicos: \\(&gt;\\) \\(&gt;=\\) \\(&lt;\\) \\(&lt;=\\) \\(==\\) \\(!=\\) #Redefinimos los valores A y B A &lt;- 10 B &lt;- 20 #Realizamos comparaciones lógicas A &gt; B ## [1] FALSE A &gt;= B ## [1] FALSE A &lt; B ## [1] TRUE A &lt;= B ## [1] TRUE A == B ## [1] FALSE A != B ## [1] TRUE C &lt;- A != B C ## [1] TRUE Como muestra el último ejemplo, el resultado de una operación lógica puede almacenarse como el valor de un objeto. 3.1.2.2 Operadores aritméticos: #suma A &lt;- 5+6 A ## [1] 11 #Resta B &lt;- 6-8 B ## [1] -2 #cociente C &lt;- 6/2.5 C ## [1] 2.4 #multiplicacion D &lt;- 6*2.5 D ## [1] 15 3.1.2.3 Funciones: Las funciones son series de procedimientos estandarizados, que toman como imput determinados argumentos a fijar por el usuario, y devuelven un resultado acorde a la aplicación de dichos procedimientos. Su lógica de funcionamiento es: funcion(argumento1 = arg1, argumento2 = arg2) A lo largo del curso iremos viendo numerosas funciones, según lo requieran los distintos ejercicios. Sin embargo, veamos ahora algunos ejemplos para comprender su funcionamiento: paste() : concatena una serie de caracteres, indicando por última instancia como separar a cada uno de ellos paste0(): concatena una serie de caracteres sin separar sum(): suma de todos los elementos de un vector mean() promedio aritmético de todos los elementos de un vector paste(&quot;Pega&quot;,&quot;estas&quot;,4,&quot;palabras&quot;, sep = &quot; &quot;) ## [1] &quot;Pega estas 4 palabras&quot; #Puedo concatenar caracteres almacenados en objetos paste(A,B,C,sep = &quot;**&quot;) ## [1] &quot;11**-2**2.4&quot; # Paste0 pega los caracteres sin separador paste0(A,B,C) ## [1] &quot;11-22.4&quot; 1:5 ## [1] 1 2 3 4 5 sum(1:5) ## [1] 15 mean(1:5,na.rm = TRUE) ## [1] 3 3.1.2.4 Caracteres especiales R es sensible a mayúsculas y minúsculas, tanto para los nombres de las variables, como para las funciones y parámetros. Los espacios en blanco y los carriage return (enter) no son considerados por el lenguaje. Los podemos aprovechar para emprolijar el código y que la lectura sea más simple2. El numeral # se utiliza para hacer comentarios. Todo lo que se escribe después del # no es interpretado por R. Se debe utilizar un # por cada línea de código que se desea anular Los corchetes [] se utilizan para acceder a un objeto: en un vector[n° orden] en una tabla[fila, columna] en una lista[n° elemento] el signo $ también es un método de acceso. Particularmente, en los dataframes, nos permitira acceder a una determinada columna de una tabla Los paréntesis() se utilizan en las funciones para definir los parámetros. Las comas , se utilizan para separar los parametros al interior de una función. 3.1.2.5 Objetos: Existen un gran cantidad de objetos distintos en R, en lo que resepcta al curso trabajaremos principalmente con 3 de ellos: Valores Vectores Data Frames Listas 3.1.2.5.1 Valores Los valores y vectores pueden ser a su vez de distintas clases: Numeric A &lt;- 1 class(A) ## [1] &quot;numeric&quot; Character A &lt;- paste(&#39;Soy&#39;, &#39;una&#39;, &#39;concatenación&#39;, &#39;de&#39;, &#39;caracteres&#39;, sep = &quot; &quot;) A ## [1] &quot;Soy una concatenación de caracteres&quot; class(A) ## [1] &quot;character&quot; Factor A &lt;- factor(&quot;Soy un factor, con niveles fijos&quot;) class(A) ## [1] &quot;factor&quot; La diferencia entre un character y un factor es que el último tiene solo algunos valores permitidos (levels), con un orden interno predefinido (el cual ,por ejemplo, se respetará a la hora de realizar un gráfico) 3.1.2.6 Vectores Para crear un vector utilizamos el comando c(), de combinar. C &lt;- c(1, 3, 4) C ## [1] 1 3 4 sumarle 2 a cada elemento del vector anterior C &lt;- C + 2 C ## [1] 3 5 6 sumarle 1 al primer elemento, 2 al segundo, y 3 al tercer elemento del vector anterior D &lt;- C + 1:3 #esto es equivalente a hacer 3+1, 5+2, 6+9 D ## [1] 4 7 9 1:3 significa que queremos todos los números enteros desde 1 hasta 3. crear un vector que contenga las palabras: “Carlos”,“Federico”,“Pedro” E &lt;- c(&quot;Carlos&quot;,&quot;Federico&quot;,&quot;Pedro&quot;) E ## [1] &quot;Carlos&quot; &quot;Federico&quot; &quot;Pedro&quot; para acceder a algún elemento del vector, podemos buscarlo por su número de orden, entre [ ] E[2] ## [1] &quot;Federico&quot; Si nos interesa almacenar dicho valor, al buscarlo lo asignamos a un nuevo objeto, dandole el nombre que deseemos elemento2 &lt;- E[2] elemento2 ## [1] &quot;Federico&quot; para borrar un objeto del ambiente de trabajo, utilizamos el comando rm() rm(elemento2) elemento2 ## Error in eval(expr, envir, enclos): object &#39;elemento2&#39; not found También podemos cambiar el texto del segundo elemento de E, por el texto “Pablo” E[2] &lt;- &quot;Pablo&quot; E ## [1] &quot;Carlos&quot; &quot;Pablo&quot; &quot;Pedro&quot; 3.1.3 Data Frames Un Data Frame es una tabla de datos, donde cada columna representa una variable, y cada fila una observación. Este objeto suele ser central en el proceso de trabajo, y suele ser la forma en que se cargan datos externos para trabajar en el ambiente de R, y en que se exportan los resultados de nuestros trabajo. También Se puede crear como la combinación de N vectores de igual tamaño. Por ejemplo, tomamos algunos valores del Indice de salarios INDICE &lt;- c(100, 100, 100, 101.8, 101.2, 100.73, 102.9, 102.4, 103.2) FECHA &lt;- c(&quot;Oct-16&quot;, &quot;Oct-16&quot;, &quot;Oct-16&quot;, &quot;Nov-16&quot;, &quot;Nov-16&quot;, &quot;Nov-16&quot;, &quot;Dic-16&quot;, &quot;Dic-16&quot;, &quot;Dic-16&quot;) GRUPO &lt;- c(&quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;, &quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;, &quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;) Datos &lt;- data.frame(INDICE, FECHA, GRUPO) Datos ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_Registrado ## 2 100.00 Oct-16 Público ## 3 100.00 Oct-16 Privado_No_Registrado ## 4 101.80 Nov-16 Privado_Registrado ## 5 101.20 Nov-16 Público ## 6 100.73 Nov-16 Privado_No_Registrado ## 7 102.90 Dic-16 Privado_Registrado ## 8 102.40 Dic-16 Público ## 9 103.20 Dic-16 Privado_No_Registrado Tal como en un vector se ubica a los elementos mediante [ ], en un dataframe se obtienen sus elementos de la forma [fila, columna]. Otra opción es especificar la columna, mediante el operador $, y luego seleccionar dentro de esa columna el registro deseado mediante el número de orden. Datos$FECHA ## [1] Oct-16 Oct-16 Oct-16 Nov-16 Nov-16 Nov-16 Dic-16 Dic-16 Dic-16 ## Levels: Dic-16 Nov-16 Oct-16 Datos[3,2] ## [1] Oct-16 ## Levels: Dic-16 Nov-16 Oct-16 Datos$FECHA[3] ## [1] Oct-16 ## Levels: Dic-16 Nov-16 Oct-16 ¿que pasa si hacemos Datos$FECHA[3,2] ? Datos$FECHA[3,2] ## Error in `[.default`(Datos$FECHA, 3, 2): incorrect number of dimensions Nótese que el último comando tiene un número incorrecto de dimensiones, porque estamos refiriendonos 2 veces a la columna FECHA. Acorde a lo visto anteriormente, el acceso a los dataframes mediante [ ], puede utilizarse para realizar filtros sobre la base, especificando una condición para las filas. Por ejemplo, puedo utilizar los [ ] para conservar del dataframe Datos unicamente los registros con fecha de Diciembre 2016: Datos[Datos$FECHA==&quot;Dic-16&quot;,] ## INDICE FECHA GRUPO ## 7 102.9 Dic-16 Privado_Registrado ## 8 102.4 Dic-16 Público ## 9 103.2 Dic-16 Privado_No_Registrado La lógica del paso anterior sería: Accedo al dataframe Datos, pidiendo únicamente conservar las filas (por eso la condición se ubica a la izquierda de la ,) que cumplan el requisito de pertenecer a la categoría “Dic-16” de la variable FECHA. Aún más, podría aplicar el filtro y al mismo tiempo identificar una variable de interés para luego realizar un cálculo sobre aquella. Por ejemplo, podría calcular la media de los indices en el mes de Diciembre. ###Por separado Indices_Dic &lt;- Datos$INDICE[Datos$FECHA==&quot;Dic-16&quot;] Indices_Dic ## [1] 102.9 102.4 103.2 mean(Indices_Dic) ## [1] 102.8333 ### Todo junto mean(Datos$INDICE[Datos$FECHA==&quot;Dic-16&quot;]) ## [1] 102.8333 La lógica de esta sintaxis sería: “Me quedó con la variable INDICE, cuando la variable FECHA sea igual a &quot;Dic-16&quot;, luego calculo la media de dichos valores” 3.1.4 Listas Contienen una concatenación de objetos de cualquier tipo. Así como un vector contiene valores, un dataframe contiene vectores, una lista puede contener dataframes, pero también vectores, o valores, y todo ello a la vez superlista &lt;- list(A,B,C,D,E,FECHA, DF = Datos, INDICE, GRUPO) superlista ## [[1]] ## [1] Soy un factor, con niveles fijos ## Levels: Soy un factor, con niveles fijos ## ## [[2]] ## [1] -2 ## ## [[3]] ## [1] 3 5 6 ## ## [[4]] ## [1] 4 7 9 ## ## [[5]] ## [1] &quot;Carlos&quot; &quot;Pablo&quot; &quot;Pedro&quot; ## ## [[6]] ## [1] &quot;Oct-16&quot; &quot;Oct-16&quot; &quot;Oct-16&quot; &quot;Nov-16&quot; &quot;Nov-16&quot; &quot;Nov-16&quot; &quot;Dic-16&quot; &quot;Dic-16&quot; ## [9] &quot;Dic-16&quot; ## ## $DF ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_Registrado ## 2 100.00 Oct-16 Público ## 3 100.00 Oct-16 Privado_No_Registrado ## 4 101.80 Nov-16 Privado_Registrado ## 5 101.20 Nov-16 Público ## 6 100.73 Nov-16 Privado_No_Registrado ## 7 102.90 Dic-16 Privado_Registrado ## 8 102.40 Dic-16 Público ## 9 103.20 Dic-16 Privado_No_Registrado ## ## [[8]] ## [1] 100.00 100.00 100.00 101.80 101.20 100.73 102.90 102.40 103.20 ## ## [[9]] ## [1] &quot;Privado_Registrado&quot; &quot;Público&quot; &quot;Privado_No_Registrado&quot; ## [4] &quot;Privado_Registrado&quot; &quot;Público&quot; &quot;Privado_No_Registrado&quot; ## [7] &quot;Privado_Registrado&quot; &quot;Público&quot; &quot;Privado_No_Registrado&quot; Para acceder un elemento de una lista, podemos utilizar el operador $, que se puede usar a su vez de forma iterativa superlista$DF$FECHA[2] ## [1] Oct-16 ## Levels: Dic-16 Nov-16 Oct-16 3.1.5 Instalación de paquetes complementarios al R Base Hasta aquí hemos visto múltiples funciones que están contenidas dentro del lenguaje básico de R. Ahora bien, al tratarse de un software libre, los usuarios de R con más experiencia contribuyen sistemáticamente a expandir este lenguaje mediante la creación y actualización de paquetes complementarios. Lógicamente, los mismos no están incluidos en la instalación inicial del programa, pero podemos descargarlos e instalarlos al mismo tiempo con el siguiente comando: install.packages(&quot;nombre_del_paquete&quot;) Resulta recomendable ejecutar este comando desde la consola ya que solo necesitaremos correrlo una vez en nuestra computadora. Al ejecutar el mismo, se descargarán de la pagina de CRAN los archivos correspondientes al paquete hacia el directorio en donde hayamos instalado el programa. Típicamente los archivos se encontrarán en **C:Files-3.5.0**, siempre con la versión del programa correspondiente. Una vez instalado el paquete, cada vez que abramos una nueva sesión de R y querramos utilizar el mismo debemos cargarlo al ambiente de trabajo mediante la siguiente función: library(nombre_del_paquete) Nótese que al cargar/activar el paquete no son necesarias las comillas. 3.1.6 Lectura y escritura de archivos 3.1.6.1 .csv y .txt Hay muchas funciones para leer archivos de tipo .txt y .csv. La mayoría sólo cambia los parámetros que vienen por default. Es importante tener en cuenta que una base de datos que proviene de archivos .txt, o .csv puede presentar diferencias en cuanto a los siguientes parametros: encabezado delimitador (,, tab, ;) separador decimal dataframe &lt;- read.delim(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) Ejemplo. Levantar la base individual de EPH del 1er trimestre 2017 En el parametro file tengo que especificar el nombre completo del archivo, incluyendo el directorio donde se encuentra. Lo más sencillo es abrir comillas, apretar Tab y se despliega el menú de las cosas que tenemos en el directorio de trabajo. Si queremos movernos hacia arriba, agregamos ../ individual_t117 &lt;- read.table(file = &#39;Fuentes/usu_individual_t117.txt&#39;,sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) individual_t117[1:10,1:5] ## CODUSU ANO4 TRIMESTRE NRO_HOGAR COMPONENTE ## 1 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 4 ## 2 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 5 ## 3 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 6 ## 4 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 7 ## 5 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 8 ## 6 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 9 ## 7 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 10 ## 8 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 11 ## 9 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 13 ## 10 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 14 Como puede observarse aquí, las bases individuales de la EPH cuentan con más de 58.000 registros y 177 variables. Al trabajar con bases de microdatos, resulta conveniente contar con algunos comandos para tener una mirada rápida de la base, antes de comenzar a realizar los procesamientos que deseemos. Veamos algunos de ellos: #View(individual_t117) names(individual_t117) ## [1] &quot;CODUSU&quot; &quot;ANO4&quot; &quot;TRIMESTRE&quot; &quot;NRO_HOGAR&quot; &quot;COMPONENTE&quot; ## [6] &quot;H15&quot; &quot;REGION&quot; &quot;MAS_500&quot; &quot;AGLOMERADO&quot; &quot;PONDERA&quot; ## [11] &quot;CH03&quot; &quot;CH04&quot; &quot;CH05&quot; &quot;CH06&quot; &quot;CH07&quot; ## [16] &quot;CH08&quot; &quot;CH09&quot; &quot;CH10&quot; &quot;CH11&quot; &quot;CH12&quot; ## [21] &quot;CH13&quot; &quot;CH14&quot; &quot;CH15&quot; &quot;CH15_COD&quot; &quot;CH16&quot; ## [26] &quot;CH16_COD&quot; &quot;NIVEL_ED&quot; &quot;ESTADO&quot; &quot;CAT_OCUP&quot; &quot;CAT_INAC&quot; ## [31] &quot;IMPUTA&quot; &quot;PP02C1&quot; &quot;PP02C2&quot; &quot;PP02C3&quot; &quot;PP02C4&quot; ## [36] &quot;PP02C5&quot; &quot;PP02C6&quot; &quot;PP02C7&quot; &quot;PP02C8&quot; &quot;PP02E&quot; ## [41] &quot;PP02H&quot; &quot;PP02I&quot; &quot;PP03C&quot; &quot;PP03D&quot; &quot;PP3E_TOT&quot; ## [46] &quot;PP3F_TOT&quot; &quot;PP03G&quot; &quot;PP03H&quot; &quot;PP03I&quot; &quot;PP03J&quot; ## [51] &quot;INTENSI&quot; &quot;PP04A&quot; &quot;PP04B_COD&quot; &quot;PP04B1&quot; &quot;PP04B2&quot; ## [56] &quot;PP04B3_MES&quot; &quot;PP04B3_ANO&quot; &quot;PP04B3_DIA&quot; &quot;PP04C&quot; &quot;PP04C99&quot; ## [61] &quot;PP04D_COD&quot; &quot;PP04G&quot; &quot;PP05B2_MES&quot; &quot;PP05B2_ANO&quot; &quot;PP05B2_DIA&quot; ## [66] &quot;PP05C_1&quot; &quot;PP05C_2&quot; &quot;PP05C_3&quot; &quot;PP05E&quot; &quot;PP05F&quot; ## [71] &quot;PP05H&quot; &quot;PP06A&quot; &quot;PP06C&quot; &quot;PP06D&quot; &quot;PP06E&quot; ## [76] &quot;PP06H&quot; &quot;PP07A&quot; &quot;PP07C&quot; &quot;PP07D&quot; &quot;PP07E&quot; ## [81] &quot;PP07F1&quot; &quot;PP07F2&quot; &quot;PP07F3&quot; &quot;PP07F4&quot; &quot;PP07F5&quot; ## [86] &quot;PP07G1&quot; &quot;PP07G2&quot; &quot;PP07G3&quot; &quot;PP07G4&quot; &quot;PP07G_59&quot; ## [91] &quot;PP07H&quot; &quot;PP07I&quot; &quot;PP07J&quot; &quot;PP07K&quot; &quot;PP08D1&quot; ## [96] &quot;PP08D4&quot; &quot;PP08F1&quot; &quot;PP08F2&quot; &quot;PP08J1&quot; &quot;PP08J2&quot; ## [101] &quot;PP08J3&quot; &quot;PP09A&quot; &quot;PP09A_ESP&quot; &quot;PP09B&quot; &quot;PP09C&quot; ## [106] &quot;PP09C_ESP&quot; &quot;PP10A&quot; &quot;PP10C&quot; &quot;PP10D&quot; &quot;PP10E&quot; ## [111] &quot;PP11A&quot; &quot;PP11B_COD&quot; &quot;PP11B1&quot; &quot;PP11B2_MES&quot; &quot;PP11B2_ANO&quot; ## [116] &quot;PP11B2_DIA&quot; &quot;PP11C&quot; &quot;PP11C99&quot; &quot;PP11D_COD&quot; &quot;PP11G_ANO&quot; ## [121] &quot;PP11G_MES&quot; &quot;PP11G_DIA&quot; &quot;PP11L&quot; &quot;PP11L1&quot; &quot;PP11M&quot; ## [126] &quot;PP11N&quot; &quot;PP11O&quot; &quot;PP11P&quot; &quot;PP11Q&quot; &quot;PP11R&quot; ## [131] &quot;PP11S&quot; &quot;PP11T&quot; &quot;P21&quot; &quot;DECOCUR&quot; &quot;IDECOCUR&quot; ## [136] &quot;RDECOCUR&quot; &quot;GDECOCUR&quot; &quot;PDECOCUR&quot; &quot;ADECOCUR&quot; &quot;PONDIIO&quot; ## [141] &quot;TOT_P12&quot; &quot;P47T&quot; &quot;DECINDR&quot; &quot;IDECINDR&quot; &quot;RDECINDR&quot; ## [146] &quot;GDECINDR&quot; &quot;PDECINDR&quot; &quot;ADECINDR&quot; &quot;PONDII&quot; &quot;V2_M&quot; ## [151] &quot;V3_M&quot; &quot;V4_M&quot; &quot;V5_M&quot; &quot;V8_M&quot; &quot;V9_M&quot; ## [156] &quot;V10_M&quot; &quot;V11_M&quot; &quot;V12_M&quot; &quot;V18_M&quot; &quot;V19_AM&quot; ## [161] &quot;V21_M&quot; &quot;T_VI&quot; &quot;ITF&quot; &quot;DECIFR&quot; &quot;IDECIFR&quot; ## [166] &quot;RDECIFR&quot; &quot;GDECIFR&quot; &quot;PDECIFR&quot; &quot;ADECIFR&quot; &quot;IPCF&quot; ## [171] &quot;DECCFR&quot; &quot;IDECCFR&quot; &quot;RDECCFR&quot; &quot;GDECCFR&quot; &quot;PDECCFR&quot; ## [176] &quot;ADECCFR&quot; &quot;PONDIH&quot; summary(individual_t117)[,c(8,10,31,133)] ## MAS_500 PONDERA IMPUTA P21 ## N:31790 Min. : 25.0 Min. :0.000000 Min. : -9 ## S:26885 1st Qu.: 137.0 1st Qu.:0.000000 1st Qu.: 0 ## Median : 238.0 Median :0.000000 Median : 0 ## Mean : 467.3 Mean :0.002727 Mean : 3671 ## 3rd Qu.: 541.0 3rd Qu.:0.000000 3rd Qu.: 4800 ## Max. :7001.0 Max. :1.000000 Max. :300000 ## head(individual_t117)[,1:5] ## CODUSU ANO4 TRIMESTRE NRO_HOGAR COMPONENTE ## 1 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 4 ## 2 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 5 ## 3 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 6 ## 4 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 7 ## 5 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 8 ## 6 TQRMNOQURHKOMLCDEFIAH00469284 2017 1 1 9 3.1.6.2 Excel Para leer y escribir archivos excel debemos utilizar los comandos que vienen con la librería openxlsx # install.packages(&quot;openxlsx&quot;) # por única vez library(openxlsx) #activamos la librería #creamos una tabla cualquiera de prueba x &lt;- 1:10 y &lt;- 11:20 tabla_de_R &lt;- data.frame(x,y) # escribimos el archivo # write.xlsx( x = tabla_de_R, file = &quot;archivo.xlsx&quot;,row.names = FALSE) #Donde lo guardó? Hay un directorio por default en caso de que no hayamos definido alguno. #getwd() #Si queremos exportar multiples dataframes a un Excel, debemos armar previamente una lista de ellos. Cada dataframe, se guardará en una pestaña de excel, cuyo nombre correspondera al que definamos para cada Dataframe a la hora de crear la lista. Lista_a_exportar &lt;- list(&quot;Indices Salarios&quot; = Datos, &quot;Tabla Numeros&quot; = tabla_de_R) # write.xlsx( x = Lista_a_exportar, file = &quot;archivo_2_hojas.xlsx&quot;,row.names = FALSE) #leemos el archivo especificando la ruta (o el directorio por default) y el nombre de la hoja que contiene los datos # Indices_Salario &lt;- read.xlsx(xlsxFile = &quot;archivo_2_hojas.xlsx&quot;,sheet = &quot;Indices Salarios&quot;) #alternativamente podemos especificar el número de orden de la hoja que deseamos levantar # Indices_Salario &lt;- read.xlsx(xlsxFile = &quot;archivo_2_hojas.xlsx&quot;,sheet = 1) # Indices_Salario 3.1.7 Ambientes de trabajo Hay algunas cosas que tenemos que tener en cuenta respecto del orden del ambiente en el que trabajamos: Working Directory: El directorio de trabajo, pueden ver el suyo con getwd(), es hacia donde apunta el código, por ejemplo, si quieren leer un archivo, la ruta del archivo tiene que estar explicitada como el recorrido desde el Working Directory. Environment: Esto engloba tanto la información que tenemos cargada en Data y Values, como las librerías que tenemos cargadas mientras trabajamos. Es importante que mantengamos bien delimitadas estas cosas entre diferentes trabajos, sino: El directorio queda referido a un lugar específico en nuestra computadora. Si se lo compartimos a otro se rompe Si cambiamos de computadora se rompe Si lo cambiamos de lugar se rompe Si primero abrimos otro script se rompe Tenemos mezclados resultados de diferentes trabajos: Nunca sabemos si esa variable/tabla/lista se creo en ese script y no otro Perdemos espacio de la memoria No estamos seguros de que el script cargue todas las librerías que necesita Rstudio tiene una herramienta muy útil de trabajo que son los proyectos. Estos permiten mantener un ambiente de trabajo delimitado por cada uno de nuestros trabajos. Es decir: El directorio de trabajo se refiere a donde esta ubicado el archivo .Rproj El Environment es específico de nuestro proyecto. Un proyecto no es un sólo script, sino toda una carpeta de trabajo. logo Rpoject Para crearlo, vamos al logo de nuevo projecto (Arriba a la izquierda de la panatalla), y elegimos la carpeta de trabajo. 3.1.8 Paquetes a utilizar a lo largo del curso: Para quienes esten trabajando con sus computadoras personales, dejamos a continuación un listado de los paquetes complementarios del R base que utilizaremos a lo largo del curso. Como la instalación requiere descargar múltiples archivos de internet recomendamos hacerlo cuando dispongan de una buena conexión. Con el siguiente comando podrían instalarlos todos de una vez: install.packages(c(&quot;tidyverse&quot;,&quot;openxlsx&quot;,&#39;ggplot2&#39;,&#39;ggthemes&#39;, &#39;ggrepel&#39;,&#39;ggalt&#39;,&#39;kableExtra&#39;)) 3.1.9 Ejercicios para practicar Reiniciar R (Session --&gt; Restart R) Crear un OBJETO llamado OBJETO definido como el resultado de la suma: 5 + 6 Crear un VECTOR VEC0 que contenga los números 1, 3, 4. Crear 3 vectores ( VEC1, VEC2, VEC3) que sean transformaciones del anterior Crear 3 vectores con la misma cantidad de elementos que VEC0, pero con variables string (texto) ( VEC4, VEC5, VEC6). Crear un dataframe DFRAME como combinación de todos los vectores creados previamente Levantar la base Individual del 1er trimestre de 2017, de la EPH Levantar del Excel llamado CANASTAS que se encuentra en la carpeta de Fuentes, la hoja “CBT” y definirla como HojaCBT. Pueden usar la función read.xlsx de cualquiera de las siguientes librerías: Vista en clase: openxlsx Otra opción que utiliza otros parametros: readxl 3.1.10 Ejercicios de tarea Crear un nuevo script en la carpeta de la clase 1 nombrado “Nombre_Alumno_Tarea_C1.R”, y realizar los siguientes procedimientos: Crear un OBJETO llamado COSA definido como el resultado de la multiplicación: 5*6 Crear un VECTOR VECTOR0 que contenga los números 10, 20, 30. Modificar el segundo elemento del VECTOR0, asignandole el valor 40 Crear 3 vectores con la misma cantidad de elementos que VEC0, pero con variables string (texto) ( VECTOR1, VECTOR2, VECTOR3). Crear un dataframe DATAF como combinación de todos los vectores creados previamente Crear un objeto llamado OTRA_COSA que guarde el valor contenido en la segunda fila y tercera columna del dataframe DATAF Levantar la base Individual del 4to trimestre de 2016, de la EPH Levantar del Excel llamado CANASTAS que se encuentra en la carpeta de Fuentes, la hoja “CBA” y definirla como HojaCBA. Más allá de los comandos elementales, comandos más sofisticados tienen muchas versiones, y algunas quedan en desuso en el tiempo.↩ veremos que existen ciertas excepciones con algunos paquetes más adelante.↩ "],
["tidyverse-y-tasas-basicas-del-mercado-de-trabajo.html", "Capítulo 4 Tidyverse y Tasas básicas del Mercado de Trabajo 4.1 Estructuración de Bases de Datos 4.2 Dplyr 4.3 Joins 4.4 Tidyr 4.5 Tasas del Mercado de Trabajo 4.6 Ejercicios para practicar", " Capítulo 4 Tidyverse y Tasas básicas del Mercado de Trabajo Reiniciar R 4.1 Estructuración de Bases de Datos A lo largo de esta clase, trabajaremos con el paquete Tidyverse. El mismo agrupa una serie de paquetes que tienen una misma lógica en su diseño y por ende funcionan en armonía. Entre ellos usaremos principalmente dplyr y tidyr para realizar transformaciones sobre nuestro set de datos, y ggplot para realizar gráficos (éste último se verá en la clase 3). A continuación cargamos la librería a nuestro ambiente. Para ello debe estar previamente instalada en nuestra pc. library(tidyverse) Para mostrar el funcionamiento básico de tydyverse, crearemos un pequeño set de datos del Indice de salarios. INDICE &lt;- c(100, 100, 100, 101.8, 101.2, 100.73, 102.9, 102.4, 103.2) FECHA &lt;- c(&quot;Oct-16&quot;, &quot;Oct-16&quot;, &quot;Oct-16&quot;, &quot;Nov-16&quot;, &quot;Nov-16&quot;, &quot;Nov-16&quot;, &quot;Dic-16&quot;, &quot;Dic-16&quot;, &quot;Dic-16&quot;) GRUPO &lt;- c(&quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;, &quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;, &quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;) Datos &lt;- data.frame(INDICE, FECHA, GRUPO) 4.2 Dplyr El caracter principal para utilizar este paquete es %&gt;% , pipe (de tubería). Los %&gt;% toman el set de datos a su izquierda, y los transforman mediante los comandos a su derecha, en los cuales los elementos de la izquierda están implícitos. Es decír, que una vez específicado el DataFrame con el cual se trabaja, no será necesario nombrarlo nuevamente para referirse a una determinada variable/columna del mismo. Veamos las principales funciones que pueden utilizarse con la lógica de este paquete: 4.2.1 filter Permite filtrar la tabla acorde al cumplimiento de condiciones lógicas Datos %&gt;% filter(INDICE&gt;101 , GRUPO == &quot;Privado_Registrado&quot;) ## INDICE FECHA GRUPO ## 1 101.8 Nov-16 Privado_Registrado ## 2 102.9 Dic-16 Privado_Registrado Nótese que en este caso al separar con una , las condiciones se exige el cumplimiento de ambas. En caso de desear que se cumpla una sola condición debe utilizarse el caracter | Datos %&gt;% filter(INDICE&gt;101 | GRUPO == &quot;Privado_Registrado&quot;) ## INDICE FECHA GRUPO ## 1 100.0 Oct-16 Privado_Registrado ## 2 101.8 Nov-16 Privado_Registrado ## 3 101.2 Nov-16 Público ## 4 102.9 Dic-16 Privado_Registrado ## 5 102.4 Dic-16 Público ## 6 103.2 Dic-16 Privado_No_Registrado 4.2.2 rename Permite renombrar una columna de la tabla. Funciona de la siguiente manera: Data %&gt;% rename( nuevo_nombre = viejo_nombre ) Datos %&gt;% rename(Periodo = FECHA) ## INDICE Periodo GRUPO ## 1 100.00 Oct-16 Privado_Registrado ## 2 100.00 Oct-16 Público ## 3 100.00 Oct-16 Privado_No_Registrado ## 4 101.80 Nov-16 Privado_Registrado ## 5 101.20 Nov-16 Público ## 6 100.73 Nov-16 Privado_No_Registrado ## 7 102.90 Dic-16 Privado_Registrado ## 8 102.40 Dic-16 Público ## 9 103.20 Dic-16 Privado_No_Registrado Nótese que a diferencia del ejemplo de la función filter donde utilizábamos == para comprobar una condición lógica, en este caso se utiliza sólo un = ya que lo estamos haciendo es asignar un nombre. 4.2.3 mutate Permite agregar una variable a la tabla (especificando el nombre que tomará esta), que puede ser el resultado de operaciones sobre otras variables de la misma tabla. En caso de especificar el nombre de una columna existente, el resultado de la operación realizada “sobrescribirá” la información de la columna con dicho nombre Datos &lt;- Datos %&gt;% mutate(Doble=INDICE*2) Datos ## INDICE FECHA GRUPO Doble ## 1 100.00 Oct-16 Privado_Registrado 200.00 ## 2 100.00 Oct-16 Público 200.00 ## 3 100.00 Oct-16 Privado_No_Registrado 200.00 ## 4 101.80 Nov-16 Privado_Registrado 203.60 ## 5 101.20 Nov-16 Público 202.40 ## 6 100.73 Nov-16 Privado_No_Registrado 201.46 ## 7 102.90 Dic-16 Privado_Registrado 205.80 ## 8 102.40 Dic-16 Público 204.80 ## 9 103.20 Dic-16 Privado_No_Registrado 206.40 4.2.4 case_when Permite definir una variable, la cual toma un valor particular para cada condición establecida. En caso de no cumplir ninguna de las condiciones establecidas la variable tomara valor NA. Su funcionamiento es el siguiente: case_when(condicion1 ~ &quot;Valor1&quot;,condicion2 ~ &quot;Valor2&quot;,condicion3 ~ &quot;Valor3&quot;) Datos &lt;- Datos %&gt;% mutate(Caso_cuando = case_when(GRUPO == &quot;Privado_Registrado&quot; ~ INDICE*2, GRUPO == &quot;Público&quot; ~ INDICE*3, GRUPO == &quot;Privado_No_Registrado&quot;~ INDICE*5)) Datos ## INDICE FECHA GRUPO Doble Caso_cuando ## 1 100.00 Oct-16 Privado_Registrado 200.00 200.00 ## 2 100.00 Oct-16 Público 200.00 300.00 ## 3 100.00 Oct-16 Privado_No_Registrado 200.00 500.00 ## 4 101.80 Nov-16 Privado_Registrado 203.60 203.60 ## 5 101.20 Nov-16 Público 202.40 303.60 ## 6 100.73 Nov-16 Privado_No_Registrado 201.46 503.65 ## 7 102.90 Dic-16 Privado_Registrado 205.80 205.80 ## 8 102.40 Dic-16 Público 204.80 307.20 ## 9 103.20 Dic-16 Privado_No_Registrado 206.40 516.00 4.2.5 select Permite especificar la serie de columnas que se desea conservar de un DataFrame. También pueden especificarse las columnas que se desean descartar (agregándoles un -). Muy útil para agilizar el trabajo en bases de datos de gran tamaño. Datos2 &lt;- Datos %&gt;% select(INDICE, FECHA, GRUPO) Datos2 ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_Registrado ## 2 100.00 Oct-16 Público ## 3 100.00 Oct-16 Privado_No_Registrado ## 4 101.80 Nov-16 Privado_Registrado ## 5 101.20 Nov-16 Público ## 6 100.73 Nov-16 Privado_No_Registrado ## 7 102.90 Dic-16 Privado_Registrado ## 8 102.40 Dic-16 Público ## 9 103.20 Dic-16 Privado_No_Registrado Datos &lt;- Datos %&gt;% select(-c(Doble,Caso_cuando)) Datos ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_Registrado ## 2 100.00 Oct-16 Público ## 3 100.00 Oct-16 Privado_No_Registrado ## 4 101.80 Nov-16 Privado_Registrado ## 5 101.20 Nov-16 Público ## 6 100.73 Nov-16 Privado_No_Registrado ## 7 102.90 Dic-16 Privado_Registrado ## 8 102.40 Dic-16 Público ## 9 103.20 Dic-16 Privado_No_Registrado 4.2.6 arrange Permite ordenar la tabla por los valores de determinada/s variable/s. Es útil cuando luego deben hacerse otras operaciones que requieran del ordenamiento de la tabla Datos &lt;- Datos %&gt;% arrange(GRUPO, INDICE) Datos ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_No_Registrado ## 2 100.73 Nov-16 Privado_No_Registrado ## 3 103.20 Dic-16 Privado_No_Registrado ## 4 100.00 Oct-16 Privado_Registrado ## 5 101.80 Nov-16 Privado_Registrado ## 6 102.90 Dic-16 Privado_Registrado ## 7 100.00 Oct-16 Público ## 8 101.20 Nov-16 Público ## 9 102.40 Dic-16 Público 4.2.7 summarise Crea una nueva tabla que resume la información original. Para ello, definimos las variables de resumen y las formas de agregación. Datos %&gt;% summarise(Indprom = mean(INDICE)) ## Indprom ## 1 101.3589 4.2.8 group_by Esta función permite realizar operaciones de forma agrupada. Lo que hace la función es “separar” a la tabla según los valores de la variable indicada y realizar las operaciones que se especifican a continuación, de manera independiente para cada una de las “subtablas”. En nuestro ejemplo, sería útil para calcular el promedio de los indices por Fecha Datos %&gt;% group_by(FECHA) %&gt;% summarise(Indprom = mean(INDICE)) ## # A tibble: 3 x 2 ## FECHA Indprom ## &lt;fct&gt; &lt;dbl&gt; ## 1 Dic-16 103. ## 2 Nov-16 101. ## 3 Oct-16 100 Notese que los %&gt;% pueden usarse encadenados para realizar numerosos procedimientos sobre un dataframe original. Veamos un ejemplo con multiples encadenamietnos Encadenado &lt;- Datos %&gt;% filter(GRUPO == &quot;Privado_Registrado&quot;) %&gt;% rename(Periodo = FECHA) %&gt;% mutate(Doble = INDICE*2) %&gt;% select(-INDICE) 4.3 Joins Otra implementación muy importante del paquete dplyr son las funciones para unir tablas (joins) fuente: http://rstudio-pubs-static.s3.amazonaws.com/227171_618ebdce0b9d44f3af65700e833593db.html 4.3.1 left_join Veamos un ejemplo de la función left_join (una de las más utilizadas en la práctica). Para ello crearemos previamente un Dataframe que contenga un Ponderador para cada uno de los Grupos del Dataframe Datos. Aprovecharemos el ejemplo para introducir la función weigthed.mean, y así calcular un Indice Ponderado. Ponderadores &lt;- data.frame(GRUPO = c(&quot;Privado_Registrado&quot;,&quot;Público&quot;,&quot;Privado_No_Registrado&quot;), PONDERADOR = c(50.16,29.91,19.93)) Ponderadores ## GRUPO PONDERADOR ## 1 Privado_Registrado 50.16 ## 2 Público 29.91 ## 3 Privado_No_Registrado 19.93 Datos_join &lt;- Datos %&gt;% left_join(.,Ponderadores, by = &quot;GRUPO&quot;) Datos_join ## INDICE FECHA GRUPO PONDERADOR ## 1 100.00 Oct-16 Privado_No_Registrado 19.93 ## 2 100.73 Nov-16 Privado_No_Registrado 19.93 ## 3 103.20 Dic-16 Privado_No_Registrado 19.93 ## 4 100.00 Oct-16 Privado_Registrado 50.16 ## 5 101.80 Nov-16 Privado_Registrado 50.16 ## 6 102.90 Dic-16 Privado_Registrado 50.16 ## 7 100.00 Oct-16 Público 29.91 ## 8 101.20 Nov-16 Público 29.91 ## 9 102.40 Dic-16 Público 29.91 Datos_Indice_Gral &lt;- Datos_join %&gt;% group_by(FECHA) %&gt;% summarise(Indice_Gral = weighted.mean(INDICE,w = PONDERADOR)) Datos_Indice_Gral ## # A tibble: 3 x 2 ## FECHA Indice_Gral ## &lt;fct&gt; &lt;dbl&gt; ## 1 Dic-16 103. ## 2 Nov-16 101. ## 3 Oct-16 100 4.4 Tidyr El paquete tidyr esta pensado para facilitar el emprolijamiento de los datos. Gather es una función que nos permite pasar los datos de forma horizontal a una forma vertical. spread es una función que nos permite pasar los datos de forma vertical a una forma horizontal. fuente: http://www.gis-blog.com/data-management-with-r-tidyr-part-1/ Retomemos el Dataframe original para mostrar como operan estas funciones: Datos ## INDICE FECHA GRUPO ## 1 100.00 Oct-16 Privado_No_Registrado ## 2 100.73 Nov-16 Privado_No_Registrado ## 3 103.20 Dic-16 Privado_No_Registrado ## 4 100.00 Oct-16 Privado_Registrado ## 5 101.80 Nov-16 Privado_Registrado ## 6 102.90 Dic-16 Privado_Registrado ## 7 100.00 Oct-16 Público ## 8 101.20 Nov-16 Público ## 9 102.40 Dic-16 Público 4.4.1 Gather y Spread Datos_Spread &lt;- Datos %&gt;% spread(., # el . llama a lo que esta atras del %&gt;% key = GRUPO, #la llave es la variable cuyos valores van a dar los nombres de columnas value = INDICE) #los valores con que se llenan las celdas Datos_Spread ## FECHA Privado_No_Registrado Privado_Registrado Público ## 1 Dic-16 103.20 102.9 102.4 ## 2 Nov-16 100.73 101.8 101.2 ## 3 Oct-16 100.00 100.0 100.0 ##La función opuesta (gather) nos permite obtener un dataframe como el original partiendo de un dataframe como el recién construido. Datos_gather &lt;- Datos_Spread %&gt;% gather(., # el . llama a lo que esta atras del %&gt;% key = GRUPO, # como se llamará la variable que toma los nombres de las columnas value = INDICE, # como se llamará la variable que toma los valores de las columnas 2:4) #le indico que columnas juntar Datos_gather ## FECHA GRUPO INDICE ## 1 Dic-16 Privado_No_Registrado 103.20 ## 2 Nov-16 Privado_No_Registrado 100.73 ## 3 Oct-16 Privado_No_Registrado 100.00 ## 4 Dic-16 Privado_Registrado 102.90 ## 5 Nov-16 Privado_Registrado 101.80 ## 6 Oct-16 Privado_Registrado 100.00 ## 7 Dic-16 Público 102.40 ## 8 Nov-16 Público 101.20 ## 9 Oct-16 Público 100.00 4.5 Tasas del Mercado de Trabajo Luego de abordar las principales funciones necesarias para operar sobre las bases de datos, trabajaremos a continuación con la base del 1er Trimestre de 2017 de la EPH. El ejercicio principal consistirá en calcular la tasa de empleo, definida como: Tasa de empleo: \\(\\frac{Ocupados}{Población}\\) Una vez alcanzado dicho resultado, se extenderá el ejercicio hacia el conjunto de tasas básicas presentadas en los Cuadros 1.1 y 1.2, del Informe técnico elaborado por EPH-INDEC. Por último se realizará una modificación para calcular al mismo tiempo las tasas básicas de 2 trimestres consecutivos. En la carpeta de FUENTES del curso, se encuentra el archivo “EPH_Registro” que contiene las codificación de cada una de las variables de la base, y el archivo “EPH_Concpetos_Actividad” que contiene las definiciones de los Estados ocupacionales a partir de los cuales se construyen las tasas básicas. Cargamos la librería que usaremos para leer y escribir archivos en excel. library(openxlsx) Carga de Informacion La función list.files nos permite observar los archivos que contiene una determinada carpeta list.files(&quot;../Fuentes/&quot;) ## character(0) La función read.table nos permite levantar los archivos de extensión “.txt” La función read.xlsx nos permite levantar los archivos de extensión “.xlsx” Levantamos la base individual del primer trimestre de 2017, y un listado que contiene los Nombres y Códigos de los Aglomerados EPH. Individual_t117 &lt;- read.table(&quot;Fuentes/usu_individual_t117.txt&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;, header = TRUE, fill = TRUE ) Aglom &lt;- read.xlsx(&quot;Fuentes/Aglomerados EPH.xlsx&quot;) 4.5.1 Tasa de Empleo Creamos una tabla con los niveles de: Población Ocupados Estos niveles nos van a permitir calcular la tasa de forma sencilla. Población: Si contaramos cuantos registros tiene la base, simplemente tendríamos el numero de individuos muestral de la EPH, por ende debemos sumar los valores de la variable PONDERA, para contemplar a cuantas personas representa cada individuo encuestado. Ocupados: En este caso, debemos agregar un filtro al procedimiento anterior, ya que unicamente queremos sumar los ponderadores de aquellas personas que se encuentran ocupadas. (La lógica seria: “Suma los valores de la columna PONDERA, solo para aquellos registros donde el ESTADO == 1”) Poblacion_ocupados &lt;- Individual_t117 %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1])) Poblacion_ocupados ## Poblacion Ocupados ## 1 27416497 11328384 La función summarise() nos permite crear multiples variables de resumen al mismo tiempo, simplemente separando con una , cada uno de ellas. A su vez, se pueden crear variables, a partir de las variables creadas por la propia función. De esta forma, podemos, directamente calcular la tasa de empleo a partir del total poblacional y de ocupados. Empleo &lt;- Individual_t117 %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1]), Tasa_Empleo = Ocupados/Poblacion) Empleo ## Poblacion Ocupados Tasa_Empleo ## 1 27416497 11328384 0.4131959 Una vez calculada la tasa, incluso podríamos desechar las variables de nivel, para conservar unicamente la tasas Empleo %&gt;% select(-(1:2)) ## Tasa_Empleo ## 1 0.4131959 4.5.2 Tásas Básicas - Total Aglomerados Con la misma lógica del ejemplo anterior, podemos construir con solo una porción de código adicional el Cuadro 1.1 del Informe técnico de Mercado de trabajo EPH-INDEC. ####Cuadro 1.1 Principales indicadores. Total 31 aglomerados u Cuadro_1.1a &lt;- Individual_t117 %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1]), Desocupados = sum(PONDERA[ESTADO == 2]), PEA = Ocupados + Desocupados, Ocupados_demand = sum(PONDERA[ESTADO == 1 &amp; PP03J ==1]), Suboc_demandante = sum(PONDERA[ESTADO == 1 &amp; INTENSI ==1 &amp; PP03J==1]), Suboc_no_demand = sum(PONDERA[ESTADO == 1 &amp; INTENSI ==1 &amp; PP03J %in% c(2,9)]), Subocupados = Suboc_demandante + Suboc_no_demand , # También podemos llamar a las variables entre comillas, incluyendo nombres compuestos # A su vez, podemos utilizar la variable recién creada en la definción de otra varible &#39;Tasa Actividad&#39; = PEA/Poblacion, &#39;Tasa Empleo&#39; = Ocupados/Poblacion, &#39;Tasa Desocupacion&#39; = Desocupados/PEA, &#39;Tasa ocupados demandantes&#39; = Ocupados_demand/PEA, &#39;Tasa Subocupación&#39; = Subocupados/PEA, &#39;Tasa Subocupación demandante&#39; = Suboc_demandante/PEA, &#39;Tasa Subocupación no demandante&#39; = Suboc_no_demand/PEA) Cuadro_1.1a ## Poblacion Ocupados Desocupados PEA Ocupados_demand Suboc_demandante ## 1 27416497 11328384 1149128 12477512 1757938 829323 ## Suboc_no_demand Subocupados Tasa Actividad Tasa Empleo Tasa Desocupacion ## 1 410709 1240032 0.4551096 0.4131959 0.09209592 ## Tasa ocupados demandantes Tasa Subocupación Tasa Subocupación demandante ## 1 0.1408885 0.09938135 0.06646541 ## Tasa Subocupación no demandante ## 1 0.03291594 Una vez que calculamos las tasas, podemos borrar los niveles poblacionales con un select Cuadro_1.1a &lt;- Cuadro_1.1a %&gt;% select(-c(1:8)) Cuadro_1.1a ## Tasa Actividad Tasa Empleo Tasa Desocupacion Tasa ocupados demandantes ## 1 0.4551096 0.4131959 0.09209592 0.1408885 ## Tasa Subocupación Tasa Subocupación demandante ## 1 0.09938135 0.06646541 ## Tasa Subocupación no demandante ## 1 0.03291594 Con gather podemos dar vuelta la tabla para que quede como en la publicación Cuadro_1.1a &lt;- Cuadro_1.1a %&gt;% gather(Tasas, Valor, 1:ncol(.)) Cuadro_1.1a ## Tasas Valor ## 1 Tasa Actividad 0.45510964 ## 2 Tasa Empleo 0.41319589 ## 3 Tasa Desocupacion 0.09209592 ## 4 Tasa ocupados demandantes 0.14088850 ## 5 Tasa Subocupación 0.09938135 ## 6 Tasa Subocupación demandante 0.06646541 ## 7 Tasa Subocupación no demandante 0.03291594 En caso de querer expresar los resultados como porcentajes, utilizamos la función sprintf. Para ello debemos utilizar mutate para transformar la columna Valor. Cuadro_1.1a &lt;- Cuadro_1.1a %&gt;% mutate(Valor = sprintf(&quot;%1.1f%%&quot;, 100*Valor)) Cuadro_1.1a ## Tasas Valor ## 1 Tasa Actividad 45.5% ## 2 Tasa Empleo 41.3% ## 3 Tasa Desocupacion 9.2% ## 4 Tasa ocupados demandantes 14.1% ## 5 Tasa Subocupación 9.9% ## 6 Tasa Subocupación demandante 6.6% ## 7 Tasa Subocupación no demandante 3.3% Nótese que en este caso, para poder añadir el %, la función transforma a la variable en un Character, por ende debe tenerse en cuenta que se pierde la información del numero completo. 4.5.3 Tásas Básicas por Aglomerado En este caso, podemos ver que simplemente agregando la función group_by podemos replicar el procedimiento para cada uno de los aglomerados. Y a su vez, podemos realizar en un solo paso los arreglos posteriores sobre nuestra tabla. Cuadro_1.2a &lt;- Individual_t117 %&gt;% group_by(AGLOMERADO) %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1]), Desocupados = sum(PONDERA[ESTADO == 2]), PEA = Ocupados + Desocupados, Ocupados_demand = sum(PONDERA[ESTADO == 1 &amp; PP03J == 1]), Suboc_demandante = sum(PONDERA[ESTADO == 1 &amp; INTENSI == 1 &amp; PP03J == 1]), Suboc_no_demand = sum(PONDERA[ESTADO == 1 &amp; INTENSI == 1 &amp; PP03J %in% c(2, 9)]), Subocupados = Suboc_demandante + Suboc_no_demand, &#39;Tasa Actividad&#39; = PEA/Poblacion, &#39;Tasa Empleo&#39; = Ocupados/Poblacion, &#39;Tasa Desocupacion&#39; = Desocupados/PEA, &#39;Tasa ocupados demandantes&#39; = Ocupados_demand/PEA, &#39;Tasa Subocupación&#39; = Subocupados/PEA, &#39;Tasa Subocupación demandante&#39; = Suboc_demandante/PEA, &#39;Tasa Subocupación no demandante&#39; = Suboc_no_demand/PEA) Cuadro_1.2a[1:10,] ## # A tibble: 10 x 16 ## AGLOMERADO Poblacion Ocupados Desocupados PEA Ocupados_demand ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2 860385 359528 31209 390737 51047 ## 2 3 308455 131538 10823 142361 11802 ## 3 4 1293438 554680 63370 618050 90662 ## 4 5 519469 206044 11279 217323 12185 ## 5 6 218671 90908 4181 95089 7247 ## 6 7 356298 138937 5928 144865 11973 ## 7 8 383974 133077 1867 134944 7660 ## 8 9 220357 82286 4639 86925 8478 ## 9 10 937900 380621 18830 399451 35043 ## 10 12 369673 148114 5956 154070 7086 ## # … with 10 more variables: Suboc_demandante &lt;int&gt;, Suboc_no_demand &lt;int&gt;, ## # Subocupados &lt;int&gt;, `Tasa Actividad` &lt;dbl&gt;, `Tasa Empleo` &lt;dbl&gt;, `Tasa ## # Desocupacion` &lt;dbl&gt;, `Tasa ocupados demandantes` &lt;dbl&gt;, `Tasa ## # Subocupación` &lt;dbl&gt;, `Tasa Subocupación demandante` &lt;dbl&gt;, `Tasa ## # Subocupación no demandante` &lt;dbl&gt; Cuadro_1.2a &lt;- Cuadro_1.2a %&gt;% select(-c(2:9)) %&gt;% # Eliminamos las variables de nivel left_join(.,Aglom) %&gt;% # Agregamos el nombre de los aglomerados, que teniamos en otro DF select(Nom_Aglo,everything(.),-AGLOMERADO) #Eliminamos el código de los aglomerados ## Joining, by = &quot;AGLOMERADO&quot; Cuadro_1.2a[1:10,] ## # A tibble: 10 x 8 ## Nom_Aglo `Tasa Actividad` `Tasa Empleo` `Tasa Desocupac… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &quot; Gran … 0.454 0.418 0.0799 ## 2 &quot; Bahía… 0.462 0.426 0.0760 ## 3 &quot; Gran … 0.478 0.429 0.103 ## 4 &quot; Gran … 0.418 0.397 0.0519 ## 5 &quot; Gran … 0.435 0.416 0.0440 ## 6 &quot; Posad… 0.407 0.390 0.0409 ## 7 &quot; Gran … 0.351 0.347 0.0138 ## 8 &quot; Cdro.… 0.394 0.373 0.0534 ## 9 &quot; Gran … 0.426 0.406 0.0471 ## 10 &quot; Corri… 0.417 0.401 0.0387 ## # … with 4 more variables: `Tasa ocupados demandantes` &lt;dbl&gt;, `Tasa ## # Subocupación` &lt;dbl&gt;, `Tasa Subocupación demandante` &lt;dbl&gt;, `Tasa ## # Subocupación no demandante` &lt;dbl&gt; 4.5.4 Ejercicio para 2 trimestres A continuación se detallaran los procedimientos necesarios para realizar apilar las bases de dos o más trimestres y calcular de manera conjunta indicadores para cada uno de ellos. Levantamos la base del 4to Trimestre de 2016 Individual_t416 &lt;- read.table(&quot;Fuentes/usu_individual_t416.txt&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;, header = TRUE, fill = TRUE ) 4.5.4.1 Select - variables de interés Para este tipo de ejercicios, donde el volumen de datos es relativamente grande, puede resultar útil restringir la base a nuestras variables de interés para que el procesamiento no sea tan costoso. Para ello, creando previamente un vector de strings con los nombres de las variables, podemos utilizar de la siguiente manera la función select para quedarnos sólamente con las mismas. Variables_interes &lt;- c(&quot;ANO4&quot;,&quot;TRIMESTRE&quot;,&quot;ESTADO&quot;,&quot;PONDERA&quot;,&quot;REGION&quot;,&quot;AGLOMERADO&quot;) Basesita_t416 &lt;- Individual_t416 %&gt;% select(Variables_interes) Basesita_t117 &lt;- Individual_t117 %&gt;% select(Variables_interes) 4.5.4.2 bind_rows La función bind_rows nos permitirá apilar dos bases de datos en un solo dataframe. La misma evalua los nombres de las variables de cada una de las bases para adjuntar el contenido de ambas en las variables comunes. En caso de que una de las bases tuviera una variable que la otra no, se conservaran dichos datos, quedando como NA los valores para la otra base. Union_Bases &lt;- bind_rows(Basesita_t416,Basesita_t117) ##alternativamente Union_Bases &lt;- Basesita_t416 %&gt;% bind_rows(Basesita_t117) Una vez que contamos con nuestra unión de las bases de 2 o más trimestres, procederemos a realizar los cálculos que deseamos agrupando por las variables ANO4 y TRIMESTRE. Esto nos permitirá realizar estimaciones para sendos períodos al mismo tiempo. Por ejemplo, a continuación tomamos parte del código desarrollado anteriormente para calcular las tasas de Actividad, Empleo, y Desocupación. Tasas_dos_trimestres &lt;- Union_Bases %&gt;% group_by(ANO4,TRIMESTRE) %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1]), Desocupados = sum(PONDERA[ESTADO == 2]), PEA = Ocupados + Desocupados, &#39;Tasa Actividad&#39; = PEA/Poblacion, &#39;Tasa Empleo&#39; = Ocupados/Poblacion, &#39;Tasa Desocupacion&#39; = Desocupados/PEA) %&gt;% select(1:2,7:ncol(.)) Tasas_dos_trimestres ## # A tibble: 2 x 5 ## # Groups: ANO4 [2] ## ANO4 TRIMESTRE `Tasa Actividad` `Tasa Empleo` `Tasa Desocupacion` ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2016 4 0.453 0.419 0.0756 ## 2 2017 1 0.455 0.413 0.0921 4.5.4.3 Exportar resultados a Excel Como vieramos en la clase 1, la función write.xlsx de la libreria openxlsx nos permite exportar los dos dataframes a un mismo archivo. Cabe aclarar que existen numerosas funciones y librerías alternativas para exportar resultados a un excel. En este caso, optamos por openxlsx ya que resulta una de las más sencillas para exportar rapidamente los resultados. Otras librerías permiten también dar formato a las tablas que se exportan, definir si deseamos sobreescribir archivos en caso de que ya existan, etc. Lista_a_exportar &lt;- list(&quot;Cuadro 1.1&quot; = Cuadro_1.1a, &quot;Cuadro 1.2&quot; = Cuadro_1.2a) # write.xlsx(Lista_a_exportar,&quot;../Resultados/Informe Mercado de Trabajo.xlsx&quot;) 4.6 Ejercicios para practicar Levantar la última base individual de EPH Crear un vector llamado Variables que contenga los nombres de las variables de interés que refieren a las siguientes características: - Edad, Sexo, Ingreso de la ocupación principal, Categoría ocupacional, ESTADO, PONDERA y PONDIH Acotar la Base únicamente a las variables de interés, utilizando el vector Variables Calcular las tasas de actividad, empleo y desempleo según sexo, para jóvenes entre 18 y 35 años Calcular el salario promedio por sexo, para dos grupos de edad: 18 a 35 años y 36 a 70 años. (Recordatorio: La base debe filtrarse para contener únicamente OCUPADOS ASALARIADOS) Grabar los resultados en un excel 4.6.1 Ejercicios de tarea Replicar el cálculo de las tasas logradas en clase para distintos trimestres, levantando las bases desde el segundo trimestre 2016 hasta la última. Tips: juntar las bases con el comando bind_rows() Probar con gather() y spread() como quedan mejor los resultados Grabar los resultados en un excel "],
["calculo-de-pobreza-por-linea.html", "Capítulo 5 Cálculo de Pobreza por Línea 5.1 Canastas Trimestrales por Region 5.2 Unidades de Adulto Equivalente por hogar en la base Individual 5.3 Cálculo de Tasas de Pobreza e Indigencia 5.4 Ejercicios Para prácticar 5.5 Ejercicios de tarea", " Capítulo 5 Cálculo de Pobreza por Línea En esta clase abordaremos conceptos teóricos y definiciones metodológicas de la medición “indirecta” de la pobreza, a través del metodo usualmente conococido como “Porbreza por Línea”, acorde a la Metodología n° 22 de INDEC. Luego, procederemos a realizar una estimación de la incidencia de la pobreza e indigencia por personas. Conceptos a abordar: Medición indirecta de la satisfacción de necesidades básicas Umbral de necesidades energéticas y proteicas Unidades de Adulto Equivalente Composición de la canasta básica alimentaria (Diferenciación regional) Población de Referencia Coeficiente de Engel Canasta Básica Total Pobreza como fenómeno del hogar Ingreso total familiar Reiniciar R Cargamos las librerías necesarias para realizar este ejercicio library(tidyverse, warn = FALSE) library(openxlsx, warn = FALSE) Aprovechando la facilidad que presenta el R para trabajar con multiples bases de datos, realizaremos la estimación de la incidencia para 2 trimestres consecutivos. Previo a levantar las bases, definimos un vector que contiene las variables relevantes para el ejercicio. Luego a la hora de levantar aplicamos un select al *dataframe** para conservar solo estas variables. Finalmente, para realizar la estimación conjunta de los dos trimestres, unimos ambas bases de datos var.ind &lt;- c(&#39;CODUSU&#39;,&#39;NRO_HOGAR&#39; ,&#39;COMPONENTE&#39;,&#39;ANO4&#39;,&#39;TRIMESTRE&#39;,&#39;REGION&#39;, &#39;AGLOMERADO&#39;, &#39;PONDERA&#39;, &#39;CH04&#39;, &#39;CH06&#39;, &#39;ITF&#39;, &#39;PONDIH&#39;,&#39;P21&#39;) individual.316 &lt;- read.table(&quot;Fuentes/usu_individual_t316.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) %&gt;% select(var.ind) individual.416 &lt;- read.table(&quot;Fuentes/usu_individual_t416.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) %&gt;% select(var.ind) Bases &lt;- bind_rows(individual.316,individual.416) A su vez levantaremos las siguientes fuentes secundarias: Unidades de Adulto equivalente según sexo y edad Canasta Básica Alimentaria Regionales de cada una de las regiones Canasta Básica Total Regionales de cada una de las regiones Diccionario de códigos de regiones y aglomerados de EPH La información de estos cuadros fue extraída del comunicado de pobreza. Adequi &lt;- read.xlsx(&quot;Fuentes/ADEQUI.xlsx&quot;) CBA &lt;- read.xlsx(&quot;Fuentes/CANASTAS.xlsx&quot;,sheet = &quot;CBA&quot;) CBT &lt;- read.xlsx(&quot;Fuentes/CANASTAS.xlsx&quot;,sheet = &quot;CBT&quot;) dic.regiones &lt;- read.xlsx(&quot;Fuentes/Regiones.xlsx&quot;) CBT ## Año Mes GBA Pampeana Noroeste Noreste Cuyo Patagonia ## 1 2016 7 4032.88 4017.66 3281.04 3396.40 3854.62 4712.59 ## 2 2016 8 4036.87 4007.81 3269.01 3394.32 3844.95 4723.38 ## 3 2016 9 4089.82 4075.69 3326.94 3451.12 3917.54 4790.98 ## 4 2016 10 4191.81 4173.73 3397.68 3524.49 4006.63 4924.99 ## 5 2016 11 4247.99 4225.38 3417.85 3539.66 4038.84 4967.62 ## 6 2016 12 4257.55 4227.33 3420.17 3551.79 4045.75 4994.91 CBA ## Año Mes GBA Pampeana Noroeste Noreste Cuyo Patagonia ## 1 2016 7 1666.48 1660.19 1458.24 1496.21 1494.04 1713.67 ## 2 2016 8 1675.05 1662.99 1459.38 1501.91 1496.09 1723.86 ## 3 2016 9 1711.22 1705.31 1498.62 1540.68 1536.29 1767.89 ## 4 2016 10 1739.34 1731.84 1516.82 1559.51 1559.00 1797.44 ## 5 2016 11 1762.65 1753.27 1532.67 1573.18 1577.67 1819.64 ## 6 2016 12 1766.62 1754.08 1526.86 1571.59 1574.22 1822.96 Adequi[1:10,] ## CH04 CH06 adequi ## 1 1 -1 0.35 ## 2 1 1 0.37 ## 3 1 2 0.46 ## 4 1 3 0.51 ## 5 1 4 0.55 ## 6 1 5 0.60 ## 7 1 6 0.64 ## 8 1 7 0.66 ## 9 1 8 0.68 ## 10 1 9 0.69 dic.regiones ## Region REGION ## 1 GBA 1 ## 2 Pampeana 43 ## 3 Noroeste 40 ## 4 Noreste 41 ## 5 Cuyo 42 ## 6 Patagonia 44 5.1 Canastas Trimestrales por Region Dado que en las bases de microdatos de EPH no se publica el mes correspondiente a cada uno de los registros individuales, las estimación de pobreza que pueden realizar los usuarios necesariamente debe ser a partir de canastas trimestrales. Para ello, a partir de los datos mensuales de la Canasta Básica Alimentaria y Total publicados por INDEC, calculamos un valor trimestral de ambas canastas, para un Adulto Equivalente perteneciente a cada una de las regiones. A vez, necesitaremos una tabla que pueda unirse con la base de datos de la EPH para asignar a cada registro, su canasta correspondiente (acorde al trimestre y a la región). CBA &lt;- CBA %&gt;% mutate(Canasta = &#39;CBA&#39;) CBT &lt;- CBT %&gt;% mutate(Canasta = &#39;CBT&#39;) Canastas_Reg &lt;- bind_rows(CBA,CBT) %&gt;% gather(.,Region, Valor, c(3:(ncol(.)-1) )) %&gt;% mutate(Trimestre = case_when(Mes %in% c(1:3) ~1, Mes %in% c(4:6) ~2, Mes %in% c(7:9) ~3, Mes %in% c(10:12) ~4), Periodo = paste(Año, Trimestre, sep=&#39;.&#39;)) Canastas_Reg[1:10,] ## Año Mes Canasta Region Valor Trimestre Periodo ## 1 2016 7 CBA GBA 1666.48 3 2016.3 ## 2 2016 8 CBA GBA 1675.05 3 2016.3 ## 3 2016 9 CBA GBA 1711.22 3 2016.3 ## 4 2016 10 CBA GBA 1739.34 4 2016.4 ## 5 2016 11 CBA GBA 1762.65 4 2016.4 ## 6 2016 12 CBA GBA 1766.62 4 2016.4 ## 7 2016 7 CBT GBA 4032.88 3 2016.3 ## 8 2016 8 CBT GBA 4036.87 3 2016.3 ## 9 2016 9 CBT GBA 4089.82 3 2016.3 ## 10 2016 10 CBT GBA 4191.81 4 2016.4 Habiendo agregado el identificador del período, promediamos las canastas de un mismo trimestre y luego le agregamos el código de la region correspondiente que nos permitirá unir este Dataframe con la base de microdatos de la EPH Canastas_Reg_2 &lt;- Canastas_Reg %&gt;% group_by(Canasta, Region, Periodo) %&gt;% summarise(Valor = mean(Valor)) %&gt;% spread(., Canasta,Valor) %&gt;% left_join(., dic.regiones, by = &quot;Region&quot;) %&gt;% ungroup() Canastas_Reg_2 ## # A tibble: 12 x 5 ## Region Periodo CBA CBT REGION ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Cuyo 2016.3 1509. 3872. 42 ## 2 Cuyo 2016.4 1570. 4030. 42 ## 3 GBA 2016.3 1684. 4053. 1 ## 4 GBA 2016.4 1756. 4232. 1 ## 5 Noreste 2016.3 1513. 3414. 41 ## 6 Noreste 2016.4 1568. 3539. 41 ## 7 Noroeste 2016.3 1472. 3292. 40 ## 8 Noroeste 2016.4 1525. 3412. 40 ## 9 Pampeana 2016.3 1676. 4034. 43 ## 10 Pampeana 2016.4 1746. 4209. 43 ## 11 Patagonia 2016.3 1735. 4742. 44 ## 12 Patagonia 2016.4 1813. 4963. 44 5.2 Unidades de Adulto Equivalente por hogar en la base Individual Incorporamos a cada registro de nuestra base la Unidad de Adulto Equivalente (UAE) correspondiente, matcheando las columnas de Edad (CH06) y Sexo (CH04) mediante la función left_join. Pobreza_Individual &lt;- Bases %&gt;% mutate(Periodo = paste(ANO4, TRIMESTRE, sep=&#39;.&#39;)) %&gt;% left_join(., Adequi, by = c(&quot;CH04&quot;, &quot;CH06&quot;)) %&gt;% left_join(., Canastas_Reg_2, by = c(&quot;REGION&quot;, &quot;Periodo&quot;)) Pobreza_Individual[1:10,1:10] ## CODUSU NRO_HOGAR COMPONENTE ANO4 TRIMESTRE ## 1 TQRMNOQWXHLMMLCDEFIAH00469008 1 3 2016 3 ## 2 TQRMNORPTHJMKTCDEFIAH00469111 1 1 2016 3 ## 3 TQRMNORPTHJMKTCDEFIAH00469111 1 2 2016 3 ## 4 TQRMNORPTHJMKTCDEFIAH00469111 1 3 2016 3 ## 5 TQRMNORPTHJMKTCDEFIAH00469111 1 4 2016 3 ## 6 TQRMNORPUHJMKTCDEFIAH00469112 1 1 2016 3 ## 7 TQRMNORPUHJMKTCDEFIAH00469112 1 2 2016 3 ## 8 TQRMNOTPSHJMKTCDEFIAH00469114 1 1 2016 3 ## 9 TQRMNOTPSHJMKTCDEFIAH00469114 1 2 2016 3 ## 10 TQRMNOTPSHJMKTCDEFIAH00469114 1 3 2016 3 ## REGION AGLOMERADO PONDERA CH04 CH06 ## 1 43 2 561 1 17 ## 2 43 2 569 1 50 ## 3 43 2 569 2 48 ## 4 43 2 569 2 23 ## 5 43 2 569 1 15 ## 6 43 2 569 2 55 ## 7 43 2 569 1 34 ## 8 43 2 569 1 70 ## 9 43 2 569 2 61 ## 10 43 2 569 2 17 Utilizamos la función group_by para calcular el total de UAE por hogar. Notesé que al usar la función mutate creamos una nueva columna, permitiendo conservar la dimensión individual de la base. Pobreza_Individual_paso2 &lt;- Pobreza_Individual %&gt;% group_by(CODUSU, NRO_HOGAR, Periodo) %&gt;% mutate(Adequi_hogar = sum(adequi)) %&gt;% ungroup() Pobreza_Individual_paso2[1:10,1:10] ## # A tibble: 10 x 10 ## CODUSU NRO_HOGAR COMPONENTE ANO4 TRIMESTRE REGION AGLOMERADO PONDERA ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 TQRMN… 1 3 2016 3 43 2 561 ## 2 TQRMN… 1 1 2016 3 43 2 569 ## 3 TQRMN… 1 2 2016 3 43 2 569 ## 4 TQRMN… 1 3 2016 3 43 2 569 ## 5 TQRMN… 1 4 2016 3 43 2 569 ## 6 TQRMN… 1 1 2016 3 43 2 569 ## 7 TQRMN… 1 2 2016 3 43 2 569 ## 8 TQRMN… 1 1 2016 3 43 2 569 ## 9 TQRMN… 1 2 2016 3 43 2 569 ## 10 TQRMN… 1 3 2016 3 43 2 569 ## # … with 2 more variables: CH04 &lt;dbl&gt;, CH06 &lt;dbl&gt; En base a las UAE del hogar al que pertenece cada individuo calculamos el valor de las canastas que delimitan las lineas de pobreza e indigencia correspondientes. Realizamos la comparación lógica entre el Ingreso Total Familiar y las Canastas calculadas para asignar a cada individuo su “situación” mediante la función case_when. Pobreza_Individual_paso3 &lt;- Pobreza_Individual_paso2 %&gt;% mutate(CBA = CBA*Adequi_hogar, CBT = CBT*Adequi_hogar, Situacion = case_when(ITF&lt;CBA ~ &#39;Indigente&#39;, ITF&gt;=CBA &amp; ITF&lt;CBT ~ &#39;Pobre&#39;, ITF&gt;=CBT ~ &#39;No.Pobre&#39;)) Pobreza_Individual_paso3[1:10,1:10] ## # A tibble: 10 x 10 ## CODUSU NRO_HOGAR COMPONENTE ANO4 TRIMESTRE REGION AGLOMERADO PONDERA ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 TQRMN… 1 3 2016 3 43 2 561 ## 2 TQRMN… 1 1 2016 3 43 2 569 ## 3 TQRMN… 1 2 2016 3 43 2 569 ## 4 TQRMN… 1 3 2016 3 43 2 569 ## 5 TQRMN… 1 4 2016 3 43 2 569 ## 6 TQRMN… 1 1 2016 3 43 2 569 ## 7 TQRMN… 1 2 2016 3 43 2 569 ## 8 TQRMN… 1 1 2016 3 43 2 569 ## 9 TQRMN… 1 2 2016 3 43 2 569 ## 10 TQRMN… 1 3 2016 3 43 2 569 ## # … with 2 more variables: CH04 &lt;dbl&gt;, CH06 &lt;dbl&gt; 5.3 Cálculo de Tasas de Pobreza e Indigencia Habiendo identificado a cada persona como pobre, indigente o no pobre el paso final para calcular la incidencia de la pobreza e indigencia requiere realizar un conteo de estos casos (Para lo cual se requiere sumar los ponderadores (PONDIH) de los registros que cumplen con una u otroa condición) Pobreza_resumen &lt;- Pobreza_Individual_paso3 %&gt;% group_by(Periodo) %&gt;% summarise(Tasa_pobreza = sum(PONDIH[Situacion %in% c(&#39;Pobre&#39;, &#39;Indigente&#39;)],na.rm = TRUE)/ sum(PONDIH,na.rm = TRUE), Tasa_indigencia = sum(PONDIH[Situacion == &#39;Indigente&#39;],na.rm = TRUE)/ sum(PONDIH,na.rm = TRUE)) Pobreza_resumen ## # A tibble: 2 x 3 ## Periodo Tasa_pobreza Tasa_indigencia ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2016.3 0.307 0.0662 ## 2 2016.4 0.300 0.0568 En caso de querer calcular la pobreza para otros subgrupos poblacionales, simplemente se requiere replicar el cálculo con la tabla agrupada según la variable de interés Pobreza_resumen_region &lt;- Pobreza_Individual_paso3 %&gt;% group_by(Periodo,Region) %&gt;% summarise(Tasa_pobreza = sum(PONDIH[Situacion %in% c(&#39;Pobre&#39;, &#39;Indigente&#39;)],na.rm = TRUE)/ sum(PONDIH,na.rm = TRUE), Tasa_indigencia = sum(PONDIH[Situacion == &#39;Indigente&#39;],na.rm = TRUE)/ sum(PONDIH,na.rm = TRUE)) Pobreza_resumen_region ## # A tibble: 12 x 4 ## # Groups: Periodo [2] ## Periodo Region Tasa_pobreza Tasa_indigencia ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2016.3 Cuyo 0.350 0.0469 ## 2 2016.3 GBA 0.304 0.0714 ## 3 2016.3 Noreste 0.339 0.0575 ## 4 2016.3 Noroeste 0.311 0.0530 ## 5 2016.3 Pampeana 0.308 0.0716 ## 6 2016.3 Patagonia 0.220 0.0349 ## 7 2016.4 Cuyo 0.364 0.0405 ## 8 2016.4 GBA 0.289 0.0597 ## 9 2016.4 Noreste 0.319 0.0455 ## 10 2016.4 Noroeste 0.322 0.0566 ## 11 2016.4 Pampeana 0.301 0.0613 ## 12 2016.4 Patagonia 0.258 0.0312 5.4 Ejercicios Para prácticar Calcular el % de pobreza e indigencia para mujeres y varones (3 y 4to trimestre 2017) Calcular el % de hogares bajo la linea de pobreza e indigencia, a nivel nacional y abierto por regiones (3 y 4to trimestre 2017) 5.5 Ejercicios de tarea Calcular el % de pobreza e indigencia para mujeres y varones en cada una de las regiones(3 y 4to trimestre 2017) "],
["graficos-y-distribucion-del-ingreso.html", "Capítulo 6 Gráficos y Distribución del Ingreso 6.1 Gráficos Básicos en R 6.2 Ggplot2 6.3 Graficos Ingresos - EPH 6.4 Ejercicios", " Capítulo 6 Gráficos y Distribución del Ingreso Reiniciar Sesión 6.1 Gráficos Básicos en R Rbase tiene algunos comandos genéricos para realizar gráficos, que se adaptan al tipo de información que se le pide graficar, por ejemplo: plot() hist() ## iris es un set de datos clásico, que ya viene incorporado en R iris[1:10,] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa plot(iris) ##Al especificar una variable, puedo ver el valor que toma cada uno de sus registros (Index) plot(iris$Sepal.Length,type = &quot;p&quot;) ## Un punto por cada valor plot(iris$Sepal.Length,type = &quot;l&quot;) ## Una linea que una cada valor plot(iris$Sepal.Length,type = &quot;b&quot;) ##Ambas hist(iris$Sepal.Length, col = &quot;lightsalmon1&quot;, main = &quot;Histograma&quot;) 6.1.1 png La función png() nos permite grabar una imagen en el disco. Lleva como argumento principal la ruta completa a donde se desea guardar la misma, incluyendo el nombre que queremos dar al archivo. A su vez pueden especificarse otros argumetnos como el ancho y largo de la imagen, entre otros. ruta_archivo &lt;- &quot;Resultados/grafico1.PNG&quot; ruta_archivo ## [1] &quot;Resultados/grafico1.PNG&quot; png(ruta_archivo) plot(iris$Sepal.Length,type = &quot;b&quot;) dev.off() ## png ## 2 La función png() abre el dispositivo de imagen en el directorio especificado. Luego creamos el gráfico que deseamos (o llamamos a uno previamente construido), el cual se desplegará en la ventana inferior derecha de la pantalla de Rstudio. Finalmente con dev.off() se cierra el dispositivo y se graban los gráficos. Los gráficos del R base son útiles para escribir de forma rápida y obtener alguna información mientras trabajamos. Muchos paquetes estadísticos permiten mostrar los resultados de forma gráfica con el comando plot (por ejemplo, las regresiones lineales lm()). Sin embargo, existen librerías mucho mejores para crear gráficos de nivel de publicación. La más importante es ggplot2, que a su vez tiene extensiones mediante otras librerías. 6.2 Ggplot2 ggplot tiene su sintaxis propia. La idea central es pensar los gráficos como una sucesión de capas, que se construyen una a la vez. El operador + nos permite incorporar nuevas capas al gráfico. El comando ggplot() nos permite definir la fuente de datos y las variables que determinaran los ejes del grafico (x,y), así como el color y la forma de las líneas o puntos,etc. Las sucesivas capas nos permiten definir: Uno o más tipos de gráficos (de columnas, geom_col(), de línea, geom_line(), de puntos,geom_point(), boxplot, geom_boxplot()) Títulos labs() Estilo del gráfico theme() Escalas de los ejes scale_y_continuous,scale_x_discrete División en subconjuntos facet_wrap(),facet_grid() ggplot tiene muchos comandos, y no tiene sentido saberlos de memoria, es siempre útil reutilizar gráficos viejos y tener a mano el machete. 6.2.1 Gráfico de Puntos A continuación se desplega un gráfico de varias capas de construcción, con su correspondiente porción de código. En el mismo se buscará visualizar, a partir de la base de datos iris la relación entre el ancho y el largo de los petalos, mediante un gráfico de puntos. library(ggplot2) ## cargamos la librería ggplot(data = iris, aes(x = Petal.Length, Petal.Width, color = Species))+ geom_point(alpha=0.75)+ labs(title = &quot;Medidas de los pétalos por especie&quot;)+ theme(legend.position = &#39;none&#39;)+ facet_wrap(~Species) ### Capas del Gráfico Veamos ahora, el “paso a paso” del armado del mismo. En primera instancia solo defino los ejes. Y en este caso un color particular para cada Especie. g &lt;- ggplot(data = iris, aes(x = Petal.Length, Petal.Width, color = Species)) g Luego, defino el tipo de gráfico. El alpha me permite definir la intensidad de los puntos g &lt;- g + geom_point(alpha=0.25) g Las siguientes tres capas me permiten respectivamente: Definir el título del gráfico Quitar la leyenda Abrir el gráfico en tres fragmentos, uno para cada especie g &lt;- g + labs(title = &quot;Medidas de los pétalos por especie&quot;)+ theme(legend.position = &#39;none&#39;)+ facet_wrap(~Species) g 6.2.2 Extensiones de GGplot. La librería GGplot tiene a su vez muchas otras librerías que extienden sus potencialidades. Entre nuestras favoritas están: gganimate: Para hacer gráficos animados. ggridge: Para hacer gráficos de densidad faceteados ggally: Para hacer varios gráficos juntos. library(GGally) ggpairs(iris, mapping = aes(color = Species)) library(ggridges) ## ## Attaching package: &#39;ggridges&#39; ## The following object is masked from &#39;package:ggplot2&#39;: ## ## scale_discrete_manual ggplot(iris, aes(x = Sepal.Length, y = Species, fill=Species)) + geom_density_ridges() ## Picking joint bandwidth of 0.181 También hay extensiones que te ayudan a escribir el código, como esquisse iris &lt;- iris ##Correr en la consola esquisse::esquisser() 6.3 Graficos Ingresos - EPH A continuación utilzaremos los conceptos abordados, para realizar gráficos a partir de las variables de ingresos. Una de las ventajas del R respecto a otros softwares estadísticos, es la facilidad con la que podemos trabajar en simultaneo con multiples bases de datos. Aprovechando esta potencialidad, levantaremos a continuación 4 bases individuales de la EPH para realizar gráficos de series temporales. ##Cargamos las librerías a utilizar library(tidyverse) ## tiene ggplot, dplyr, tidyr, y otros library(ggthemes) ## estilos de gráficos library(ggrepel) ## etiquetas de texto más prolijas que las de ggplot Para mayor practicidad, al momento de levantar las bases de datos, seleccionamos las variables necesarias (A excepción de la base del t1_2017 con la que trabajaremos numerosas variables) Individual_t117 &lt;- read.table(&quot;Fuentes/usu_individual_t117.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) Individual_t216 &lt;- read.table(&quot;Fuentes/usu_individual_t216.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) %&gt;% select(ANO4,TRIMESTRE,P21,PONDIIO,IPCF, PONDIH) Individual_t316 &lt;- read.table(&quot;Fuentes/usu_individual_t316.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE)%&gt;% select(ANO4,TRIMESTRE,P21,PONDIIO, IPCF, PONDIH) Individual_t416 &lt;- read.table(&quot;Fuentes/usu_individual_t416.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE)%&gt;% select(ANO4,TRIMESTRE,P21,PONDIIO, IPCF, PONDIH) 6.3.1 Ingreso de la ocupación principal Nuestro primer ejercicio consistirá en analizar la evolución del ingreso por la ocupación principal. Observando el diseño de registro podremos ver que dicha variable está codificada como P21. Para minimizar la volatilidad que la no respuesta de ingresos podría generar en los resultados de unos y otros trimestres, la EPH asigna a los no respondentes el comportamiento de los respondentes por estrato de la muestra. A partir de esto las variables de ingresos presentan distintos factores de expansión. En el caso del ingreso de la ocupación principal debemos trabajar con el expansor PONDIIO. ##Unimos las bases y creamos una variable que concatena el año y el trimestre Union_Bases &lt;- bind_rows(Individual_t216, Individual_t316, Individual_t416, Individual_t117) %&gt;% mutate(periodo = paste(ANO4, TRIMESTRE, sep = &quot;_&quot;)) Calculamos el ingreso per capita promedio, utilizando el ponderador correspondiente. Importante: Debemos exigir ingresos positivos, ya que tenemos numerosos casos con ingreso 0 y otros codificados con -9 (cuando no corresponde la pregunta por la ocupación principal) IOppal &lt;-Union_Bases %&gt;% filter(P21&gt;0) %&gt;% group_by(periodo) %&gt;% summarise(IOppal_prom = weighted.mean(P21, PONDIIO)) IOppal ## # A tibble: 4 x 2 ## periodo IOppal_prom ## &lt;chr&gt; &lt;dbl&gt; ## 1 2016_2 10071. ## 2 2016_3 10757. ## 3 2016_4 11533. ## 4 2017_1 12305. Ahora podemos utilizar este nuevo dataframe para graficar ggplot(data = IOppal, aes(x = periodo, y = IOppal_prom)) + geom_point() Agregando algunos parámetros más … Definimos las variables del gráfico g &lt;- IOppal %&gt;% ##Podemos usar los &quot;pipes&quot; para llamar al Dataframe que continen la info ggplot(aes(x = periodo, y = IOppal_prom, ##Agrupar nos permitirá generar las lineas del gráfico group = &#39;IOppal_prom&#39;, ##Agregamos una etiqueta a los datos (Redondeando la variable a 2 posiciones decimales) label= round(IOppal_prom,2))) Agregamos titulo y modificamos ejes g &lt;- g + labs(x = &quot;Trimestre&quot;, y = &quot;IPCF promedio&quot;, title = &quot;Ingreso promedio por la ocupación principal&quot;, subtitle = &quot;Serie 2trim_2016 - 1trim_2017&quot;, caption = &quot;Fuente: EPH&quot;) Agregamos puntos y lineas g &lt;- g + geom_point(size= 3)+ ##puedo definir tamaño de las lineas geom_line( size= 1 ) Agrego etiquetas con el texto. Las corro hacia arriba (nudge_y) y a la izquierda(nudge_x) Agrego un tema g &lt;- g + geom_text_repel(nudge_y = 500, nudge_x = 0.25)+ theme_minimal() muestro el gráfico (guardado en g) g ggsave(filename = &quot;Resultados/IPCF_prom.png&quot;) ##Guardo el Grafico ## Saving 7 x 5 in image 6.3.2 Distribución de los ingresos laborales y no laborales por sexo Ingresos no laborales : TVI Ingreso laborales: P21 MONTO DE INGRESO DE LA OCUPACIÓN PRINCIPAL Totp12 MONTO DE INGRESO DE OTRAS OCUPACIONES. datagraf_2 &lt;-Individual_t117 %&gt;% ##eligo las variables que necesito select(P47T,T_VI, TOT_P12, P21 , PONDII, CH04,NIVEL_ED) %&gt;% ## Me quedo con los que tienen ingreso total individual (P47) positivo filter(!is.na(P47T), P47T &gt; 0 ) %&gt;% mutate(ingreso_laboral = TOT_P12 + P21, ingreso_no_laboral = T_VI, ingreso_total = ingreso_laboral + ingreso_no_laboral, CH04 = case_when(CH04 == 1 ~ &quot;Varon&quot;, CH04 == 2 ~ &quot;Mujer&quot;)) %&gt;% group_by(CH04) %&gt;% summarise(&#39;ingreso laboral&#39; = sum(ingreso_laboral*PONDII)/sum(ingreso_total*PONDII), &#39;ingreso no laboral&#39; = sum(ingreso_no_laboral*PONDII)/sum(ingreso_total*PONDII)) datagraf_2 ## # A tibble: 2 x 3 ## CH04 `ingreso laboral` `ingreso no laboral` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mujer 0.607 0.393 ## 2 Varon 0.813 0.187 Doy vuelta la tabla para poder graficar datagrafico &lt;- datagraf_2 %&gt;% gather(tipo_ingreso, monto,2:3 ) datagrafico ## # A tibble: 4 x 3 ## CH04 tipo_ingreso monto ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mujer ingreso laboral 0.607 ## 2 Varon ingreso laboral 0.813 ## 3 Mujer ingreso no laboral 0.393 ## 4 Varon ingreso no laboral 0.187 ggplot(datagrafico, aes(CH04, monto, fill = tipo_ingreso, label = sprintf(&quot;%1.1f%%&quot;, 100*monto)))+ geom_col(position = &quot;stack&quot;, alpha=0.6) + geom_text(position = position_stack(vjust = 0.5), size=5)+ labs(x=&quot;&quot;,y=&quot;Porcentaje&quot;)+ theme_tufte()+ scale_y_continuous()+ theme(legend.position = &quot;bottom&quot;, legend.title=element_blank(), axis.text.x = element_text(angle=25)) ggsave(filename = &quot;Resultados/ingresos laborales y no laborales.png&quot;,scale = 2) ## Saving 16 x 16 in image Podemos agregar también grupos de edad como otra dimensión del análisis. Optamos por restringuir la población de análisis a la comprendida entre 18 y 60 años ####Agrego al procedimiento anterior una clasificación de las edades datagraf_3 &lt;-Individual_t117 %&gt;% select(P47T,T_VI, TOT_P12, P21 , PONDII, CH04,CH06) %&gt;% filter(!is.na(P47T), P47T &gt; 0 , CH06 %in% c(18:60)) %&gt;% mutate(ingreso_laboral = as.numeric(TOT_P12 + P21), ingreso_no_laboral = as.numeric(T_VI), ingreso_total = ingreso_laboral + ingreso_no_laboral, CH04 = case_when(CH04 == 1 ~ &quot;Varon&quot;, CH04 == 2 ~ &quot;Mujer&quot;), EDAD = case_when(CH06 %in% c(18:30) ~ &quot;18 a 30&quot;, ##&lt;&lt; CH06 %in% c(31:45) ~&quot;31 a 45&quot;, ##&lt;&lt; CH06 %in% c(46:60) ~ &quot;46 a 60&quot;)) %&gt;% ##&lt;&lt; group_by(CH04,EDAD) %&gt;% ##&lt;&lt; summarise(&#39;ingreso laboral&#39; = sum(ingreso_laboral*PONDII)/sum(ingreso_total*PONDII), &#39;ingreso no laboral&#39; = sum(ingreso_no_laboral*PONDII)/sum(ingreso_total*PONDII)) %&gt;% gather(tipo_ingreso, monto,3:4) datagraf_3 ## # A tibble: 12 x 4 ## # Groups: CH04 [2] ## CH04 EDAD tipo_ingreso monto ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mujer 18 a 30 ingreso laboral 0.805 ## 2 Mujer 31 a 45 ingreso laboral 0.844 ## 3 Mujer 46 a 60 ingreso laboral 0.800 ## 4 Varon 18 a 30 ingreso laboral 0.907 ## 5 Varon 31 a 45 ingreso laboral 0.972 ## 6 Varon 46 a 60 ingreso laboral 0.915 ## 7 Mujer 18 a 30 ingreso no laboral 0.195 ## 8 Mujer 31 a 45 ingreso no laboral 0.156 ## 9 Mujer 46 a 60 ingreso no laboral 0.200 ## 10 Varon 18 a 30 ingreso no laboral 0.0934 ## 11 Varon 31 a 45 ingreso no laboral 0.0282 ## 12 Varon 46 a 60 ingreso no laboral 0.0855 ggplot(datagraf_3, aes(CH04, monto, fill = tipo_ingreso, label = sprintf(&quot;%1.1f%%&quot;, 100*monto)))+ geom_col(position = &quot;stack&quot;, alpha=0.6) + geom_text(position = position_stack(vjust = 0.5), size=3)+ labs(x=&quot;&quot;,y=&quot;Porcentaje&quot;)+ theme_tufte()+ scale_y_continuous()+ theme(legend.position = &quot;bottom&quot;, legend.title=element_blank(), axis.text.x = element_text(angle=25))+ facet_wrap(~EDAD) En los gráficos utilizamos extensiones de ggplot: ggrepel geom_text_repel() ggthemes theme_tufte() simplemente debemos recordar cargar las librerías si queremos utilizar esas funciones. 6.3.3 Otros gráficos Los gráficos hasta aquí realizados (barras, línea) son fácilmente reproducibles en un excel ya que utilizan la información agregada. Sin embargo, la gran ventaja del R se manifiesta a a la hora de realizar: Gráficos que necesitan la información a nivel de microdatos. puntos, boxplots, Kernels, etc. Abrir un mismo gráfico según alguna variable discreta: facet_wrap() Parametrizar otras variables, para aumentar la dimensionalidad del gráficos. color color = rellenofill = forma shape = tamaño size = transparencia alpha = Esto permite tener, en el plano, gráficos de muchas dimensiones de análisis Si el color representa una variable lo definimos dentro del aes(), aes(... color = ingresos) Cuando queremos simplemente mejorar el diseño (es fijo), se asigna por fuera, o dentro de cada tipo de gráficos, geom_col(color = 'green'). 6.3.3.1 Boxplots Los gráficos Boxplot representan una única variable (univariados). Están compuestos por una caja, cuyo límite inferior es el valor donde se alcanza el 25% de la distribución Su límite superior es el valor donde se alcanza el 75% de la misma. A su vez, también el gráfico marca los valores “outliers” (datos que se encuentran a una distancia de al menos 1,5 veces el tamaño de la caja del límite inferior o superior de la caja, según corresponda) 6.3.3.1.0.0.0.1 Boxplot de ingresos de la ocupación principal, según nivel educativo Hacemos un procesamiento simple: Sacamos los ingresos iguales a cero y las no respuestas de nivel educativo. Es importante que las variables sean del tipo que conceptualmente les corresponde (el nivel educativo es una variable categórica, no continua), para que el ggplot pueda graficarlo correctamente. ## Las variables sexo( CH04 ) y Nivel educativo están codificadas como números, y el R las entiende como numéricas. class(Individual_t117$NIVEL_ED) ## [1] &quot;integer&quot; class(Individual_t117$CH04) ## [1] &quot;integer&quot; ggdata &lt;- Individual_t117 %&gt;% filter(P21&gt;0, !is.na(NIVEL_ED)) %&gt;% mutate(NIVEL_ED = as.factor(NIVEL_ED), CH04 = as.factor(CH04)) ggplot(ggdata, aes(x = NIVEL_ED, y = P21)) + geom_boxplot()+ scale_y_continuous(limits = c(0, 40000))##Restrinjo el gráfico hasta ingresos de $40000 ## Warning: Removed 209 rows containing non-finite values (stat_boxplot). Si queremos agregar la dimensión sexo, podemos hacer un facet_wrap() ggplot(ggdata, aes(x= NIVEL_ED, y = P21, group = NIVEL_ED, fill = NIVEL_ED )) + geom_boxplot()+ scale_y_continuous(limits = c(0, 40000))+ facet_wrap(~ CH04, labeller = &quot;label_both&quot;) ## Warning: Removed 209 rows containing non-finite values (stat_boxplot). Por la forma en que está presentado el gráfico, el foco de atención sigue puesto en las diferencias de ingresos entre niveles educativo. Simplemente se agrega un corte por la variable de sexo. Si lo que queremos hacer es poner el foco de atención en las diferencias por sexo, simplemente basta con invertir la variable x especificada con la variable utilizada en el facet_wrap ggplot(ggdata, aes(x= CH04, y = P21, group = CH04, fill = CH04 )) + geom_boxplot()+ scale_y_continuous(limits = c(0, 40000))+ facet_grid(~ NIVEL_ED, labeller = &quot;label_both&quot;) + theme(legend.position = &quot;none&quot;) ## Warning: Removed 209 rows containing non-finite values (stat_boxplot). 6.3.3.2 Histogramas Otra forma de mostrar la distribución de una variable es utilizar un histograma. Este tipo de gráficos agrupa las observaciones en bins: intervalos dentro del rango de la variable. Luego cuenta la cantidad de observaciones que caen dentro de cada uno de estos bins. Por ejemplo, si observamos el ingreso de la ocupación principal: hist_data &lt;-Individual_t117 %&gt;% filter(P21&gt;0) ggplot(hist_data, aes(x = P21,weights = PONDIIO))+ geom_histogram()+ scale_x_continuous(limits = c(0,50000)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. En este gráfico, los posibles valores de p21 se dividen en 30 bins consecutivos y el gráfico muestra cuantas observaciones caen en cada uno de ellos 6.3.3.3 Kernels La función geom_density() nos permite construir kernels de la distribución. Esto es, un suavizado sobre los histogramas que se basa en alguna distribución supuesta dentro de cada bin. Es particularmente útil cuando tenemos una variable continua, dado que los histogramas rompen esa sensación de continuidad. Veamos un ejemplo sencillo con los ingresos de la ocupación principal. Luego iremos complejizandolo kernel_data &lt;-Individual_t117 %&gt;% filter(P21&gt;0) ggplot(kernel_data, aes(x = P21,weights = PONDIIO))+ geom_density()+ scale_x_continuous(limits = c(0,50000)) El eje y no tiene demasiada interpretabilidad en los Kernel, porque hace a la forma en que se construyen las distribuciones. El parametro adjust, dentro de la función geom_densitynos permite reducir o ampliar el rango de suavizado de la distribución. Su valor por default es 1. Veamos que sucede si lo seteamos en 2 ggplot(kernel_data, aes(x = P21,weights = PONDIIO))+ geom_density(adjust = 2)+ scale_x_continuous(limits = c(0,50000)) Como es esperable, la distribución del ingreso tiene “picos” en los valores redondos, ya que la gente suele declarar un valor aproximado al ingreso efectivo que percibe. Nadie declara ingresos de 30001. Al suavizar la serie con un kernel, eliminamos ese efecto.Si seteamos el rango para el suavizado en valores menores a 1, podemos observar estos picos. ggplot(kernel_data, aes(x = P21,weights = PONDIIO))+ geom_density(adjust = 0.01)+ scale_x_continuous(limits = c(0,50000)) Ahora bien, como en todo grafico de R, podemos seguir agregando dimensiones para enriquecer el análisis. kernel_data_2 &lt;- kernel_data %&gt;% mutate(CH04= case_when(CH04 == 1 ~ &quot;Varon&quot;, CH04 == 2 ~ &quot;Mujer&quot;)) ggplot(kernel_data_2, aes(x = P21, weights = PONDIIO, group = CH04, fill = CH04)) + geom_density(alpha=0.7,adjust =2)+ labs(x=&quot;Distribución del ingreso&quot;, y=&quot;&quot;, title=&quot; Total según tipo de ingreso y sexo&quot;, caption = &quot;Fuente: Encuesta Permanente de Hogares&quot;)+ scale_x_continuous(limits = c(0,50000))+ theme_tufte()+ scale_fill_gdocs()+ theme(legend.position = &quot;bottom&quot;, plot.title = element_text(size=12)) ggsave(filename = &quot;Resultados/Kernel_1.png&quot;,scale = 2) ## Saving 14 x 10 in image Podemos agregar aún la dimensión de ingreso laboral respecto del no laboral kernel_data_3 &lt;-kernel_data_2 %&gt;% select(REGION,P47T,T_VI, TOT_P12, P21 , PONDII, CH04) %&gt;% filter(!is.na(P47T), P47T &gt; 0 ) %&gt;% mutate(ingreso_laboral = TOT_P12 + P21, ingreso_no_laboral = T_VI) %&gt;% gather(., key = Tipo_ingreso, Ingreso, c((ncol(.)-1):ncol(.))) %&gt;% filter( Ingreso !=0)## Para este gráfico, quiero eliminar los ingresos = 0 kernel_data_3[1:10,] ## REGION P47T T_VI TOT_P12 P21 PONDII CH04 Tipo_ingreso Ingreso ## 1 43 1500 0 0 1500 1386 Varon ingreso_laboral 1500 ## 2 43 9500 0 0 9500 1130 Mujer ingreso_laboral 9500 ## 3 43 8000 0 0 8000 1629 Mujer ingreso_laboral 8000 ## 4 43 6000 0 0 6000 1270 Varon ingreso_laboral 6000 ## 5 43 21000 0 0 14000 2079 Mujer ingreso_laboral 14000 ## 6 43 12000 0 0 9000 1280 Mujer ingreso_laboral 9000 ## 7 43 20000 0 0 20000 1167 Varon ingreso_laboral 20000 ## 8 43 15000 0 0 15000 1284 Mujer ingreso_laboral 15000 ## 9 43 34000 0 10000 24000 1112 Mujer ingreso_laboral 34000 ## 10 43 23000 0 0 23000 1162 Varon ingreso_laboral 23000 ggplot(kernel_data_3, aes( x = Ingreso, weights = PONDII, group = Tipo_ingreso, fill = Tipo_ingreso)) + geom_density(alpha=0.7,adjust =2)+ labs(x=&quot;Distribución del ingreso&quot;, y=&quot;&quot;, title=&quot; Total según tipo de ingreso y sexo&quot;, caption = &quot;Fuente: Encuesta Permanente de Hogares&quot;)+ scale_x_continuous(limits = c(0,50000))+ theme_tufte()+ scale_fill_gdocs()+ theme(legend.position = &quot;bottom&quot;, plot.title = element_text(size=12))+ facet_wrap(~ CH04, scales = &quot;free&quot;) ggsave(filename = &quot;Resultados/Kernel_2.png&quot;,scale = 2) ## Saving 14 x 10 in image En este tipo de gráficos, importa mucho qué variable se utiliza para facetear y qué variable para agrupar, ya que la construcción de la distribución es diferente. ggplot(kernel_data_3, aes( x = Ingreso, weights = PONDII, group = CH04, fill = CH04)) + geom_density(alpha=0.7,adjust =2)+ labs(x=&quot;Distribución del ingreso&quot;, y=&quot;&quot;, title=&quot; Total según tipo de ingreso y sexo&quot;, caption = &quot;Fuente: Encuesta Permanente de Hogares&quot;)+ scale_x_continuous(limits = c(0,50000))+ theme_tufte()+ scale_fill_gdocs()+ theme(legend.position = &quot;bottom&quot;, plot.title = element_text(size=12))+ facet_wrap(~Tipo_ingreso, scales = &quot;free&quot;) ggsave(filename = &quot;Resultados/Kernel_3.png&quot;,scale = 2) ## Saving 14 x 10 in image 6.4 Ejercicios 6.4.1 Para practicar Calcular el promedio del ingreso por ocupación principal (Variable P21) para asalariados con y sin descuento jubilatorio (Variable PP07H). Luego realizar un gráfico de barras donde se comparen ambos valores (para el 1er trimestre de 2017). Pistas: Se deben filtrar previamente los ingresos mayores a 0 (P21&gt;0).Chequear que ponderador corresponde utilizar Graficar la distribución del ingreso por ocupación principal para Asalariados, Cuentapropistas y Patrones, con el tipo de gráfico Kernel Pista: Usar la función facet_wrap para separar a cada una de las categorías ocupacionales) Sugerencia: incorporar la línea scale_x_continuous(limits = c(0,50000)) entre las capas del gráfico. ¿Qué cambió? 6.4.2 De tarea Hacer un gráfico boxplot de la distribución de edades de los asalariados con descuento jubilatorio, y de los asalariados sin descuento jubilatorio. Uniendo las bases de los distintos trimestres, calcular el procentaje de asalariados sin descuento jubilatorio como \\(\\frac{Asal. s/ desc jubil}{Asal. c/ desc jubil+ Asal.s/ desc jubil}\\). Luego realizar un gráfico de linea con la evolución de este indicador "],
["pool-de-datos-en-panel-y-matrices-de-transicion.html", "Capítulo 7 Pool de Datos en Panel y Matrices de Transición 7.1 Datos De Panel 7.2 Matrices de transición 7.3 Ejercicios Para prácticar", " Capítulo 7 Pool de Datos en Panel y Matrices de Transición Reiniciar R 7.1 Datos De Panel 7.1.1 Introducción En esta clase veremos como construir un pool de datos de panel utilizando múltiples bases de la EPH. El ejercicio consiste en analizar las transiciones individuales entre las distintas categorías y estados ocupacionales. Trabajaremos con un caso sencillo, sin reclasificar a la población en más que las categorías definidas por la EPH. A su vez, para maximizar la cantidad de casos del ejercicio utilizando las bases recientemente publicadas, trabajaremos con transiciones entre trimestres (Aunque en la práctica suelen realizarse paneles anuales para observar más movilidad) Cargamos la librería tidyverse con la cual trabajaremos para procesar la información library(tidyverse, warn = FALSE) Levantamos las Bases Individuales de 4 trimestres. individual.216 &lt;- read.table(&quot;Fuentes/usu_individual_t216.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) individual.316 &lt;- read.table(&quot;Fuentes/usu_individual_t316.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) individual.416 &lt;- read.table(&quot;Fuentes/usu_individual_t416.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) individual.117 &lt;- read.table(&quot;Fuentes/usu_individual_t117.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) 7.1.2 Pasos para la construccion del Panel Creamos un Vector que contenga unicamente las variables de interés, para recortar luego la base con la funcion select. Unimos todas las bases con la función bind_rows, seleccionando solo las variables del vector. Filtramos de la base los casos de no respuesta y acotaremos en este ejercicio el analisis a la población entre 18 y 65 años. Creamos las categorías de análisis que deseamos observar en distintos perídos. Armamos un identificador ordinal para los registros de cada trimestre. Replicamos el dataframe construido y le cambiamos los nombres a todas las variables, a excepción de las que usaremos para identificar a un mismo individuo ( CODUSU, NRO_HOGAR, COMPONENTE). En la base replicada, modificamos el identificador ordinal en función de la amplitud que deseamos en las observaciones de panel. En nuestro caso como uniremos registros con distancia de 1 trimestre, le restamos 1 a cada valor Unimos ambas bases con la funcion inner_join que solo nos dejará registros que en ambas bases contengan los mismos CODUSU, NRO_HOGAR, COMPONENTE e identificador ordinal. Creamos la columna para las consistencias, y luego filtramos la base para eliminar los registros inconsistentes #Paso 1 var.ind &lt;- c(&#39;CODUSU&#39;,&#39;NRO_HOGAR&#39;,&#39;COMPONENTE&#39;, &#39;ANO4&#39;,&#39;TRIMESTRE&#39;,&#39;ESTADO&#39;,&#39;CAT_OCUP&#39;,&#39;PONDERA&#39;, &#39;CH04&#39;, &#39;CH06&#39;,&#39;P21&#39;,&#39;PP3E_TOT&#39;) #Paso 2 Bases_Continua &lt;- bind_rows( individual.216 %&gt;% select(var.ind), individual.316 %&gt;% select(var.ind), individual.416 %&gt;% select(var.ind), individual.117 %&gt;% select(var.ind)) #Pasos 3 y 4 Bases_Continua &lt;- Bases_Continua %&gt;% filter(CH06 %in% c(18:65),ESTADO !=0) %&gt;% mutate(Categoria = case_when(ESTADO %in% c(3,4)~&quot;Inactivos&quot;, ESTADO == 2 ~&quot;Desocupados&quot;, ESTADO == 1 &amp; CAT_OCUP == 1 ~&quot;Patrones&quot;, ESTADO == 1 &amp; CAT_OCUP == 2 ~&quot;Cuenta Propistas&quot;, ESTADO == 1 &amp; CAT_OCUP == 3 ~&quot;Asalariados&quot;, ESTADO == 1 &amp; CAT_OCUP == 4 ~&quot;Trabajador familiar s/r&quot;, TRUE ~ &quot;Otros&quot;)) #Paso 5 Bases_Continua &lt;- Bases_Continua %&gt;% mutate(Trimestre = paste(ANO4, TRIMESTRE, sep=&quot;_&quot;)) %&gt;% arrange(Trimestre) %&gt;% mutate(Id_Trimestre = match(Trimestre,unique(Trimestre))) #Paso 6 Bases_Continua_Replica &lt;- Bases_Continua names(Bases_Continua_Replica) ## [1] &quot;CODUSU&quot; &quot;NRO_HOGAR&quot; &quot;COMPONENTE&quot; &quot;ANO4&quot; ## [5] &quot;TRIMESTRE&quot; &quot;ESTADO&quot; &quot;CAT_OCUP&quot; &quot;PONDERA&quot; ## [9] &quot;CH04&quot; &quot;CH06&quot; &quot;P21&quot; &quot;PP3E_TOT&quot; ## [13] &quot;Categoria&quot; &quot;Trimestre&quot; &quot;Id_Trimestre&quot; names(Bases_Continua_Replica)[4:(length(Bases_Continua_Replica)-1)] &lt;- paste0(names(Bases_Continua_Replica)[4:(length(Bases_Continua_Replica)-1)],&quot;_t1&quot;) names(Bases_Continua_Replica) ## [1] &quot;CODUSU&quot; &quot;NRO_HOGAR&quot; &quot;COMPONENTE&quot; &quot;ANO4_t1&quot; ## [5] &quot;TRIMESTRE_t1&quot; &quot;ESTADO_t1&quot; &quot;CAT_OCUP_t1&quot; &quot;PONDERA_t1&quot; ## [9] &quot;CH04_t1&quot; &quot;CH06_t1&quot; &quot;P21_t1&quot; &quot;PP3E_TOT_t1&quot; ## [13] &quot;Categoria_t1&quot; &quot;Trimestre_t1&quot; &quot;Id_Trimestre&quot; #Paso 7 Bases_Continua_Replica$Id_Trimestre &lt;- Bases_Continua_Replica$Id_Trimestre - 1 #Pasos 8 y 9 Panel_Continua &lt;- inner_join(Bases_Continua,Bases_Continua_Replica) Panel_Continua &lt;- Panel_Continua %&gt;% mutate(Consistencia = case_when(abs(CH06_t1-CH06) &gt; 2 | CH04 != CH04_t1 ~ &quot;inconsistente&quot;, TRUE ~ &quot;consistente&quot;)) %&gt;% filter(Consistencia == &quot;consistente&quot;) 7.2 Matrices de transición 7.2.1 Calculo de probabilidades de transición. Realizaremos un breve ejercicio para identificar la magnitud relativa de las transiciones entre las distintas categorías ocupacionales. Para ello calculamos la suma ponderada de la cantidad de casos observados para cada posible combinación de Cateogria y Categoria_t1. Luego calcularemos la probabilidad de encontrarse en categoría en t1, condicional a haber pertenecido a las distintas categorías en t0. Categorias_transiciones &lt;- Panel_Continua %&gt;% #filter(Categoria != Categoria_t1) %&gt;% group_by(Categoria,Categoria_t1) %&gt;% summarise(frec_muestral = n(), frecuencia = sum((PONDERA+PONDERA_t1)/2)) %&gt;% ungroup() %&gt;% group_by(Categoria) %&gt;% mutate(Prob_salida = frecuencia/sum(frecuencia)) Categorias_transiciones[1:10,] ## # A tibble: 10 x 5 ## # Groups: Categoria [2] ## Categoria Categoria_t1 frec_muestral frecuencia Prob_salida ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Asalariados Asalariados 18227 8215874. 0.869 ## 2 Asalariados Cuenta Propistas 778 374916. 0.0397 ## 3 Asalariados Desocupados 503 297061 0.0314 ## 4 Asalariados Inactivos 1250 507510 0.0537 ## 5 Asalariados Patrones 115 54242 0.00574 ## 6 Asalariados Trabajador familia… 14 4002. 0.000423 ## 7 Cuenta Propist… Asalariados 758 398875 0.154 ## 8 Cuenta Propist… Cuenta Propistas 3627 1663297 0.643 ## 9 Cuenta Propist… Desocupados 210 133810. 0.0517 ## 10 Cuenta Propist… Inactivos 569 250491 0.0969 Notese que la linea comentada en el medio de la cadena de pipes, nos permitiría iterar rapidamente sobre el procedimiento anterior agregando un filtro. En este ejemplo, podríamos recalcular las proporciones únicamente para aquellas personas que presentan un movimiento de categoría 7.2.2 Gráfico de Matriz de Transición library(ggthemes) ggplot(Categorias_transiciones, aes(x = Categoria_t1, y = Categoria, fill = Prob_salida, label =round(Prob_salida*100,2))) + labs(title = &quot;Probabilidades de Transicion de hacia las distintas Categorías&quot;)+ geom_tile()+ geom_text()+ scale_fill_gradient(low = &quot;grey100&quot;, high = &quot;grey30&quot;)+ theme_tufte() 7.3 Ejercicios Para prácticar Levantar todas las bases individuales de EPH que se encuentran en la carpeta Fuentes Crear un vector llamado Variables que contenga los nombres de las siguientes variables de interés: - ANO4,TRIMESTRE,CODUSU,NRO_HOGAR,COMPONENTE,ESTADO,CH04,PONDERA Acotar la Base únicamente a las variables de interés, utilizando el vector Variables Replicar los procedimientos vistos en clase para el armado del panel de observaciones inter-trimestrales y luego calcular: - ¿Cuántos casos (muestrales y ponderados) tenemos en nuestro pool de datos en panel? - ¿Cuántos casos muestrales tenemos por cada trimestre en nuestro pool de datos? ¿Qué porcentaje de los registros totales de un trimestre representa? - ¿Cuántos casos son inconsistentes controlando por sexo en cada trimestre? Calcularlo en términos absolutos y porcentuales "],
["rmarkdown.html", "Capítulo 8 RMarkdown 8.1 Introducción 8.2 Organización de los datos 8.3 Tasas básicas de Mercado de trabajo 8.4 Empleo no registrado 8.5 Brechas de ingresos 8.6 Horas semanales trabajadas", " Capítulo 8 RMarkdown 8.1 Introducción El objetivo de esta clase es comenzar a trabajar utilizando los formatos RNotebook y/o RMarkdown para realizar reportes compilados directamente en RStudio, de forma tal que nuestro trabajo pueda quedar documentado y ser fácilmente compartido con otras personas. Mientras que en la clase presencial trabajamos bajo la modalidad de código en vivo, en las presentes notas de clase se replican los ejercicios propuestos. En lugar de abrir un R Script, en esta ocasión abriremos un nuevo documento del tipo R Notebook o R Markdown. Cargamos la librería tidyverse con la cual trabajaremos para procesar la información library(tidyverse) Asentamos en la variable date el trimestre correspondiente a la información utilizada. date &lt;- &quot;1er trimestre 2017&quot; De esta forma, cuando presentemos los resultados de nuestro análisis, podremos contar automáticamente con las etiquetas para los cuadros, gráficos y comentarios. Por ejemplo: Todos los datos refieren a los 31 aglomerados urbanos relevados en la EPH y en esta ocasión corresponden al 1er trimestre 2017. 8.2 Organización de los datos Cargamos la base individual del 1er trimestre 2017. base_individual &lt;- read.table(&quot;Fuentes/usu_individual_t117.txt&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) Modificamos la variable CH04 de la base de datos, de forma tal que se llame Sexo y contenga los valores Varones y Mujeres. De este modo los resultados se presentarán de forma más amena a su lectura. base_individual &lt;- base_individual %&gt;% mutate(Sexo = as.character(CH04), Sexo = case_when(Sexo==&quot;1&quot; ~ &quot;Varones&quot;, Sexo==&quot;2&quot; ~ &quot;Mujeres&quot;)) Construimos la variable NIVEL_EDUCATIVO, colapsando sus categorías en cuatro niveles. base_individual &lt;- base_individual %&gt;% mutate(NIVEL_EDUCATIVO = case_when(NIVEL_ED %in% c(1, 7) ~ &quot;Sin Instrucción&quot;, NIVEL_ED %in% c(2, 3) ~ &quot;Primaria&quot;, NIVEL_ED %in% c(4, 5) ~ &quot;Secundaria&quot;, NIVEL_ED == 6 ~ &quot;Superior&quot;, NIVEL_ED == 9 ~ &quot;NS/NR&quot;), NIVEL_EDUCATIVO = factor(NIVEL_EDUCATIVO, levels = c(&quot;Sin Instrucción&quot;, &quot;Primaria&quot;, &quot;Secundaria&quot;, &quot;Superior&quot;))) 8.3 Tasas básicas de Mercado de trabajo En esta instancia realizamos un ejercicio similar a los ya presentados en el curso. Calculamos las tasas de Actividad, Empleo y Desocupación, pero para cada uno de los sexos. Si queremos mostrar la tabla resultante, debemos configurar el chunk de código de forma tal que el output sea “Show output only” (en caso de querer ocultar las líneas de código), o “Show code and output” (en caso de querer compartir también el código). tabla1.1 &lt;- base_individual %&gt;% filter(CH06 &gt;= 14) %&gt;% group_by(Sexo) %&gt;% summarise(Poblacion = sum(PONDERA), Ocupados = sum(PONDERA[ESTADO == 1]), Desocupados = sum(PONDERA[ESTADO == 2]), PEA = Ocupados + Desocupados, &#39;Tasa Actividad&#39; = round(PEA/Poblacion*100, 1), &#39;Tasa Empleo&#39; = round(Ocupados/Poblacion*100, 1), &#39;Tasa Desocupación&#39; = round(Desocupados/PEA*100, 1)) %&gt;% select(-c(2:5)) %&gt;% gather(Indicadores, Valor, 2:4) %&gt;% spread(., Sexo, Valor) tabla1.1 ## # A tibble: 3 x 3 ## Indicadores Mujeres Varones ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Tasa Actividad 46.1 69.6 ## 2 Tasa Desocupación 10.2 8.5 ## 3 Tasa Empleo 41.4 63.7 Lo mismo sucede en el caso de los gráficos: Gráfico 1. Población de 14 años y más. Tasas de Actividad y de Empleo por sexo. Total de aglomerados urbanos. 1er trimestre 2017. tabla1.2_graf &lt;- tabla1.1 %&gt;% filter(Indicadores %in% c(&quot;Tasa Actividad&quot;, &quot;Tasa Empleo&quot;)) %&gt;% gather(., Sexo, porcentaje, 2:3) ggplot(tabla1.2_graf, aes(x = &#39;&#39;, porcentaje, fill = Sexo, group= Sexo, label = paste0(porcentaje, &quot;%&quot;))) + geom_col(position = &quot;dodge&quot;) + geom_text(position = position_dodge(width = .9), vjust =2, size = 6) + theme_void() + facet_grid(~Indicadores) + labs(caption = &quot;Fuente: Elaboración propia en base a EPH-INDEC&quot;) 8.4 Empleo no registrado Calculamos a continuación la tasa de empleo no registrado en el caso de las asalariadas mujeres y de los asalariados varones. tabla2.1 &lt;- base_individual %&gt;% filter(ESTADO==1, CAT_OCUP==3) %&gt;% group_by(Sexo) %&gt;% summarise(&quot;Proporción de no Registrados&quot; = round(sum(PONDERA[PP07H==2])/sum(PONDERA)*100, 1)) inline_1 &lt;- tabla2.1$`Proporción de no Registrados`[tabla2.1$Sexo == &quot;Mujeres&quot;] inline_2 &lt;- tabla2.1$`Proporción de no Registrados`[tabla2.1$Sexo == &quot;Varones&quot;] tabla2.1 ## # A tibble: 2 x 2 ## Sexo `Proporción de no Registrados` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Mujeres 35.1 ## 2 Varones 31.9 Hay un 35.1% de las asalariadas a quienes sus empleadores no inscriben en la seguridad social, mientras que para los asalariados varones esta tasa de no registro es del 31.9%. 8.5 Brechas de ingresos 8.5.1 Brecha de ingresos totales mensuales tabla3.1 &lt;- base_individual %&gt;% filter(P47T &gt; 0) %&gt;% group_by(Sexo) %&gt;% summarise(Media.ITI = round(weighted.mean(P47T, PONDII), 1)) %&gt;% spread(., Sexo, Media.ITI) %&gt;% mutate(&quot;Brecha del Ingreso Total Individual&quot; = round(((Varones-Mujeres)/Varones)*100, 1)) inline_3 &lt;- tabla3.1$`Brecha del Ingreso Total Individual` tabla3.1 ## # A tibble: 1 x 3 ## Mujeres Varones `Brecha del Ingreso Total Individual` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10708. 14687. 27.1 Observando los ingresos totales individuales de toda la población, se observa que la brecha entre varones y mujeres en este caso es de 27.1 puntos porcentuales. Es decir, contemplando todos los ingresos que se perciben, sean de origen laboral o no laboral (como jubilaciones y pensiones, cuotas alimentarias, subsidios, etc.), las mujeres perciben ingresos que, en promedio, son un 27.1% menores que los de los varones. 8.5.1.1 Ejercicio: Calcular la brecha de ingresos mensuales de las/os ocupadas/os # Resolución tabla4.1 &lt;- base_individual %&gt;% filter(ESTADO == 1) %&gt;% group_by(Sexo) %&gt;% summarise(Media.IOP = round(weighted.mean(P21, PONDIIO), 1)) %&gt;% spread(., Sexo, Media.IOP) %&gt;% mutate(&quot;Brecha de ingresos de la ocup. princ.&quot; = round(((Varones-Mujeres)/Varones)*100, 1)) inline_4 &lt;- tabla4.1$`Brecha de ingresos de la ocupación principal` inline_5 &lt;- tabla4.1$`Media de ingresos de las Mujeres` inline_6 &lt;- tabla4.1$`Media de ingresos de los Varones` tabla4.1 ## # A tibble: 1 x 3 ## Mujeres Varones `Brecha de ingresos de la ocup. princ.` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9965 13218. 24.6 Simultáneamente, en el mercado de trabajo, las mujeres ganan en promedio un % menos que los varones ( vs. ). Estos datos corresponden a la totalidad de ocupadas/os, cualquiera sea su categoría ocupacional, calificación o jerarquía, y observando en este caso los ingresos provenientes de la ocupación principal. 8.5.2 Brecha de ingresos mensuales por nivel educativo Antes de calcular la brecha de los ingresos mensuales para cada nivel educativo, veremos la distribución que presenta cada uno de los sexos respecto de esta variable. tabla5.1 &lt;- base_individual %&gt;% filter(ESTADO == 1, !is.na(NIVEL_EDUCATIVO)) %&gt;% group_by(Sexo) %&gt;% mutate(Frecuencia = sum(PONDERA)) %&gt;% group_by(Sexo, NIVEL_EDUCATIVO) %&gt;% summarise(Tasa = round(sum(PONDERA)/unique(Frecuencia)*100, 1)) %&gt;% spread(., Sexo, Tasa) %&gt;% rename(&quot;Nivel Educativo&quot; = NIVEL_EDUCATIVO, &quot;% de Mujeres&quot; = Mujeres, &quot;% de Varones&quot; = Varones) tabla5.1 ## # A tibble: 4 x 3 ## `Nivel Educativo` `% de Mujeres` `% de Varones` ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Sin Instrucción 3.6 5.1 ## 2 Primaria 23.4 37.2 ## 3 Secundaria 41.6 41.1 ## 4 Superior 31.4 16.5 Calculamos el promedio de ingresos mensuales y horarios para cada combinación de Sexo y NIVELEDUCATIVO. tabla5.2 &lt;- base_individual %&gt;% filter(ESTADO == 1, PP3E_TOT &gt; 0, PP3E_TOT != 999, !is.na(NIVEL_EDUCATIVO)) %&gt;% group_by(Sexo, NIVEL_EDUCATIVO) %&gt;% summarise(IOP_hr = round(weighted.mean(P21/(PP3E_TOT * 30 / 7), PONDIIO), 2), IOP_mensual = round(weighted.mean(P21, PONDIIO), 2)) %&gt;% arrange(NIVEL_EDUCATIVO, Sexo) 8.5.3 Brecha de ingresos mensuales y horarios por nivel educativo Presentamos los ingresos promedios y la brecha correspondientes a los ingresos mensuales. tabla5.2.1 &lt;- tabla5.2 %&gt;% select(-IOP_hr) %&gt;% spread(., Sexo, IOP_mensual) %&gt;% mutate(brecha = paste0(round((Varones-Mujeres)/Varones*100, 1), &quot;%&quot;)) tabla5.2.1 ## # A tibble: 4 x 4 ## NIVEL_EDUCATIVO Mujeres Varones brecha ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Sin Instrucción 5030. 8640. 41.8% ## 2 Primaria 5853. 9969. 41.3% ## 3 Secundaria 9025. 13505 33.2% ## 4 Superior 15369. 21135. 27.3% Presentamos los datos de montos y brecha correspondientes al ingreso por horas de las/os ocupadas/os, de acuerdo a su sexo y nivel educativo. tabla5.2.2 &lt;- tabla5.2 %&gt;% select(-IOP_mensual) %&gt;% spread(., Sexo, IOP_hr) %&gt;% mutate(brecha = paste0(round((Varones-Mujeres)/Varones*100, 1), &quot;%&quot;)) tabla5.2.2 ## # A tibble: 4 x 4 ## NIVEL_EDUCATIVO Mujeres Varones brecha ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Sin Instrucción 46.0 54.8 16.1% ## 2 Primaria 54.6 58.9 7.2% ## 3 Secundaria 68.9 79.3 13.1% ## 4 Superior 118. 134. 12% 8.6 Horas semanales trabajadas Finalmente, podemos indagar sobre los determinantes de la diferencia entre las brechas de ingresos mensuales y las brechas de ingresos horarios. Para eso, podemos ver la diferencia entre las horas que ofrecen los varones y las mujeres semanalmente en el mercado de trabajo. horas &lt;- base_individual %&gt;% filter(ESTADO == 1, PP3E_TOT &gt; 0, PP3E_TOT != 999) %&gt;% group_by(Sexo) %&gt;% summarise(&quot;Horas semanales trabajadas&quot; = round(weighted.mean(PP3E_TOT, PONDIIO), 2)) horas ## # A tibble: 2 x 2 ## Sexo `Horas semanales trabajadas` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Mujeres 32.6 ## 2 Varones 42.1 "],
["programacion-funcional.html", "Capítulo 9 Programacion Funcional 9.1 Loops 9.2 Estructuras Condicionales 9.3 Funciones 9.4 PURRR3 9.5 Ejemplo. Regresión lineal 9.6 Lectura y escritura de archivos intermedia 9.7 Ayudas 9.8 Ejercicios para practicar", " Capítulo 9 Programacion Funcional Reiniciar R library(tidyverse) library(openxlsx) library(ggthemes) library(fs) 9.1 Loops Un loop es una estructura de código que nos permite aplicar iterativamente un mismo conjunto de comandos, variando el valor de una variable. Por ejemplo: for(i in 1:10){ print(i^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 ## [1] 100 Esto se lee como : “Recorre cada uno de los valores (i) del vector numérico 1 a 10, y para cada uno de ellos imprimí el cuadrado (i^2)”. Uno puede especificar la palabra que desee que tomé cada uno de los valores que debe tomar. En el ejemplo anterior fue i, pero bien podría ser la “Valores” for(Valores in 1:10){ print(Valores^2) } ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 ## [1] 25 ## [1] 36 ## [1] 49 ## [1] 64 ## [1] 81 ## [1] 100 Un loop puede iterar sobre cualquier tipo de vector, independientemente de lo que contenga. Los loops son una estructura básica que existen en cualquier lenguaje de programación. En R no recomendamos abusar de ellos porque hacen que el código sea más lento. 9.2 Estructuras Condicionales Las estructuras condiconales nos permiten ejecutar una porción de código en caso de que cumplan una condición lógica 9.2.1 if Su funcionamiento es el siguiente: if(condicion){codigo a ejecutar si se cumple la condición} if( 2+2 == 4){ print(&quot;Menos Mal&quot;) } ## [1] &quot;Menos Mal&quot; if( 2+2 == 148.24){ print(&quot;R, tenemos un problema&quot;) } 9.2.2 ifelse La función if_else() sirve para crear o modificar dicotómicamente un objeto/variable/vector a partir del cumplimiento de una o más condiciones lógicas. Su funcionamiento es el siguiente: if_else(condicion,función a aplicar si se cumple la condición,función a aplicar si no se cumple la condición) if_else(2+2==4, true = &quot;Joya&quot;,false = &quot;Error&quot;) ## [1] &quot;Joya&quot; 9.3 Funciones La creación de funciones propias nos permite automatizar todas aquellas partes del código que se repiten mucho. Una vez diseñadas, funcionan igual que cualquier comando. Por ejemplo, podemos definir la suma de dos elementos como suma &lt;- function(valor1, valor2) { valor1+valor2 } suma(5,6) ## [1] 11 Obviamente las funciones no son sólo para variables numéricas. Por ejemplo, podemos pegar dos strings con una flecha en el medio funcion_prueba &lt;- function(parametro1,parametro2) { paste(parametro1, parametro2, sep = &quot; &lt;--&gt; &quot;) } funcion_prueba(parametro1 = &quot;A ver&quot;, parametro2 = &quot;Que pasa&quot;) ## [1] &quot;A ver &lt;--&gt; Que pasa&quot; También podemos asignar un valor por default para los parametros en caso de que el usuario no defina su valor al utilizar la función. Otra_funcion_prueba &lt;- function(parametro1 ,parametro2 = &quot;String default&quot;) { paste(parametro1, parametro2, sep = &quot; &lt;--&gt; &quot;) } Otra_funcion_prueba(parametro1 = &quot;Valor 1 &quot;) ## [1] &quot;Valor 1 &lt;--&gt; String default&quot; Las funciones que creamos nosotros permanecen en el ambiente de R temporariamente. Cuando removemos los objetos del ambiente, la función deja de existir. Por ende, debemos incorporarla en cada uno de los scripts en la cual la necesitemos. Una buena práctica, es incorporar nuestras funciones útiles al comienzo de cada script junto a la carga de las librerías. Vale mencionar que lo que ocurre en una función, queda en la función excepto que explícitamente pidamos que devuelva el resultado, con el comando print(). Las funciones siempre devuelven el último objeto que se crea en ellas, o si explicitamente se utiliza el comando return() 9.4 PURRR3 MAP es la forma tidy de hacer loops. Además de ser más prolijo el código, es mucho más eficiente. La función map toma un input, una función para aplicar, y alguna otra cosa (por ejemplo parametros que necesite la función) map(.x, .f, …) map(VECTOR_O_LIST_INPUT, FUNCTION_A_APLICAR, OTROS_OPCIONALES) Usamos map2 cuando tenemos que pasar dos input, que se aplican sobre una función: map2(.x, .y, .f, …) map2(INPUT_UNO, INPUT_DOS, FUNCTION_A_APLICAR, OTROS_OPCIONALES) Si tenemos más de dos… pmap(.l, .f, …) pmap(VECTOR_O_LIST_INPUT, FUNCTION_A_APLICAR, OTROS_OPCIONALES) Por ejemplo. Si queremos utilizar la función prueba sobre los datos del dataframe ABC_123 ABC_123 &lt;- data.frame(Letras = LETTERS[1:20],Num = 1:20) funcion_prueba ## function(parametro1,parametro2) { ## paste(parametro1, parametro2, sep = &quot; &lt;--&gt; &quot;) ## } Si el resultado que queremos es que junte cada fila, necesitamos pasarle dos parámetros: utilizamos map2() resultado &lt;- map2(ABC_123$Letras,ABC_123$Num,funcion_prueba) resultado[1:3] ## [[1]] ## [1] &quot;A &lt;--&gt; 1&quot; ## ## [[2]] ## [1] &quot;B &lt;--&gt; 2&quot; ## ## [[3]] ## [1] &quot;C &lt;--&gt; 3&quot; La salida de los map() es una lista, no un vector, por lo que si lo metemos dentro de un dataframe se vería así: ABC_123 %&gt;% mutate(resultado= map2(Letras,Num,funcion_prueba)) ## Letras Num resultado ## 1 A 1 A &lt;--&gt; 1 ## 2 B 2 B &lt;--&gt; 2 ## 3 C 3 C &lt;--&gt; 3 ## 4 D 4 D &lt;--&gt; 4 ## 5 E 5 E &lt;--&gt; 5 ## 6 F 6 F &lt;--&gt; 6 ## 7 G 7 G &lt;--&gt; 7 ## 8 H 8 H &lt;--&gt; 8 ## 9 I 9 I &lt;--&gt; 9 ## 10 J 10 J &lt;--&gt; 10 ## 11 K 11 K &lt;--&gt; 11 ## 12 L 12 L &lt;--&gt; 12 ## 13 M 13 M &lt;--&gt; 13 ## 14 N 14 N &lt;--&gt; 14 ## 15 O 15 O &lt;--&gt; 15 ## 16 P 16 P &lt;--&gt; 16 ## 17 Q 17 Q &lt;--&gt; 17 ## 18 R 18 R &lt;--&gt; 18 ## 19 S 19 S &lt;--&gt; 19 ## 20 T 20 T &lt;--&gt; 20 al ponerlo dentro del dataframe desarma la lista y guarda cada elemento por separado. La magia de eso es que podemos guardar cualquier cosa en el dataframe no sólo valores, sino también listas, funciones, dataframes, etc. Si queremos recuperar los valores originales en este caso podemos usar unlist() resultado[1:3] %&gt;% unlist() ## [1] &quot;A &lt;--&gt; 1&quot; &quot;B &lt;--&gt; 2&quot; &quot;C &lt;--&gt; 3&quot; ABC_123 %&gt;% mutate(resultado= unlist(map2(Letras,Num,funcion_prueba))) ## Letras Num resultado ## 1 A 1 A &lt;--&gt; 1 ## 2 B 2 B &lt;--&gt; 2 ## 3 C 3 C &lt;--&gt; 3 ## 4 D 4 D &lt;--&gt; 4 ## 5 E 5 E &lt;--&gt; 5 ## 6 F 6 F &lt;--&gt; 6 ## 7 G 7 G &lt;--&gt; 7 ## 8 H 8 H &lt;--&gt; 8 ## 9 I 9 I &lt;--&gt; 9 ## 10 J 10 J &lt;--&gt; 10 ## 11 K 11 K &lt;--&gt; 11 ## 12 L 12 L &lt;--&gt; 12 ## 13 M 13 M &lt;--&gt; 13 ## 14 N 14 N &lt;--&gt; 14 ## 15 O 15 O &lt;--&gt; 15 ## 16 P 16 P &lt;--&gt; 16 ## 17 Q 17 Q &lt;--&gt; 17 ## 18 R 18 R &lt;--&gt; 18 ## 19 S 19 S &lt;--&gt; 19 ## 20 T 20 T &lt;--&gt; 20 Si lo que queríamos era que la función nos haga todas las combinaciones de letras y número, entonces lo que necesitamos es pasarle el segúndo parametro como algo fijo, poniendolo después de la función. map(ABC_123$Letras,funcion_prueba,ABC_123$Num)[1:2] ## [[1]] ## [1] &quot;A &lt;--&gt; 1&quot; &quot;A &lt;--&gt; 2&quot; &quot;A &lt;--&gt; 3&quot; &quot;A &lt;--&gt; 4&quot; &quot;A &lt;--&gt; 5&quot; ## [6] &quot;A &lt;--&gt; 6&quot; &quot;A &lt;--&gt; 7&quot; &quot;A &lt;--&gt; 8&quot; &quot;A &lt;--&gt; 9&quot; &quot;A &lt;--&gt; 10&quot; ## [11] &quot;A &lt;--&gt; 11&quot; &quot;A &lt;--&gt; 12&quot; &quot;A &lt;--&gt; 13&quot; &quot;A &lt;--&gt; 14&quot; &quot;A &lt;--&gt; 15&quot; ## [16] &quot;A &lt;--&gt; 16&quot; &quot;A &lt;--&gt; 17&quot; &quot;A &lt;--&gt; 18&quot; &quot;A &lt;--&gt; 19&quot; &quot;A &lt;--&gt; 20&quot; ## ## [[2]] ## [1] &quot;B &lt;--&gt; 1&quot; &quot;B &lt;--&gt; 2&quot; &quot;B &lt;--&gt; 3&quot; &quot;B &lt;--&gt; 4&quot; &quot;B &lt;--&gt; 5&quot; ## [6] &quot;B &lt;--&gt; 6&quot; &quot;B &lt;--&gt; 7&quot; &quot;B &lt;--&gt; 8&quot; &quot;B &lt;--&gt; 9&quot; &quot;B &lt;--&gt; 10&quot; ## [11] &quot;B &lt;--&gt; 11&quot; &quot;B &lt;--&gt; 12&quot; &quot;B &lt;--&gt; 13&quot; &quot;B &lt;--&gt; 14&quot; &quot;B &lt;--&gt; 15&quot; ## [16] &quot;B &lt;--&gt; 16&quot; &quot;B &lt;--&gt; 17&quot; &quot;B &lt;--&gt; 18&quot; &quot;B &lt;--&gt; 19&quot; &quot;B &lt;--&gt; 20&quot; En este caso, el map itera sobre cada elemento de letras, y para cada elemento i hace funcion_prueba(i,ABC$Num) y guarda el resultado en la lista si lo queremos meter en el dataframe ABC_123 %&gt;% mutate(resultado= map(Letras,funcion_prueba,Num)) ## Letras Num ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 ## 9 I 9 ## 10 J 10 ## 11 K 11 ## 12 L 12 ## 13 M 13 ## 14 N 14 ## 15 O 15 ## 16 P 16 ## 17 Q 17 ## 18 R 18 ## 19 S 19 ## 20 T 20 ## resultado ## 1 A &lt;--&gt; 1, A &lt;--&gt; 2, A &lt;--&gt; 3, A &lt;--&gt; 4, A &lt;--&gt; 5, A &lt;--&gt; 6, A &lt;--&gt; 7, A &lt;--&gt; 8, A &lt;--&gt; 9, A &lt;--&gt; 10, A &lt;--&gt; 11, A &lt;--&gt; 12, A &lt;--&gt; 13, A &lt;--&gt; 14, A &lt;--&gt; 15, A &lt;--&gt; 16, A &lt;--&gt; 17, A &lt;--&gt; 18, A &lt;--&gt; 19, A &lt;--&gt; 20 ## 2 B &lt;--&gt; 1, B &lt;--&gt; 2, B &lt;--&gt; 3, B &lt;--&gt; 4, B &lt;--&gt; 5, B &lt;--&gt; 6, B &lt;--&gt; 7, B &lt;--&gt; 8, B &lt;--&gt; 9, B &lt;--&gt; 10, B &lt;--&gt; 11, B &lt;--&gt; 12, B &lt;--&gt; 13, B &lt;--&gt; 14, B &lt;--&gt; 15, B &lt;--&gt; 16, B &lt;--&gt; 17, B &lt;--&gt; 18, B &lt;--&gt; 19, B &lt;--&gt; 20 ## 3 C &lt;--&gt; 1, C &lt;--&gt; 2, C &lt;--&gt; 3, C &lt;--&gt; 4, C &lt;--&gt; 5, C &lt;--&gt; 6, C &lt;--&gt; 7, C &lt;--&gt; 8, C &lt;--&gt; 9, C &lt;--&gt; 10, C &lt;--&gt; 11, C &lt;--&gt; 12, C &lt;--&gt; 13, C &lt;--&gt; 14, C &lt;--&gt; 15, C &lt;--&gt; 16, C &lt;--&gt; 17, C &lt;--&gt; 18, C &lt;--&gt; 19, C &lt;--&gt; 20 ## 4 D &lt;--&gt; 1, D &lt;--&gt; 2, D &lt;--&gt; 3, D &lt;--&gt; 4, D &lt;--&gt; 5, D &lt;--&gt; 6, D &lt;--&gt; 7, D &lt;--&gt; 8, D &lt;--&gt; 9, D &lt;--&gt; 10, D &lt;--&gt; 11, D &lt;--&gt; 12, D &lt;--&gt; 13, D &lt;--&gt; 14, D &lt;--&gt; 15, D &lt;--&gt; 16, D &lt;--&gt; 17, D &lt;--&gt; 18, D &lt;--&gt; 19, D &lt;--&gt; 20 ## 5 E &lt;--&gt; 1, E &lt;--&gt; 2, E &lt;--&gt; 3, E &lt;--&gt; 4, E &lt;--&gt; 5, E &lt;--&gt; 6, E &lt;--&gt; 7, E &lt;--&gt; 8, E &lt;--&gt; 9, E &lt;--&gt; 10, E &lt;--&gt; 11, E &lt;--&gt; 12, E &lt;--&gt; 13, E &lt;--&gt; 14, E &lt;--&gt; 15, E &lt;--&gt; 16, E &lt;--&gt; 17, E &lt;--&gt; 18, E &lt;--&gt; 19, E &lt;--&gt; 20 ## 6 F &lt;--&gt; 1, F &lt;--&gt; 2, F &lt;--&gt; 3, F &lt;--&gt; 4, F &lt;--&gt; 5, F &lt;--&gt; 6, F &lt;--&gt; 7, F &lt;--&gt; 8, F &lt;--&gt; 9, F &lt;--&gt; 10, F &lt;--&gt; 11, F &lt;--&gt; 12, F &lt;--&gt; 13, F &lt;--&gt; 14, F &lt;--&gt; 15, F &lt;--&gt; 16, F &lt;--&gt; 17, F &lt;--&gt; 18, F &lt;--&gt; 19, F &lt;--&gt; 20 ## 7 G &lt;--&gt; 1, G &lt;--&gt; 2, G &lt;--&gt; 3, G &lt;--&gt; 4, G &lt;--&gt; 5, G &lt;--&gt; 6, G &lt;--&gt; 7, G &lt;--&gt; 8, G &lt;--&gt; 9, G &lt;--&gt; 10, G &lt;--&gt; 11, G &lt;--&gt; 12, G &lt;--&gt; 13, G &lt;--&gt; 14, G &lt;--&gt; 15, G &lt;--&gt; 16, G &lt;--&gt; 17, G &lt;--&gt; 18, G &lt;--&gt; 19, G &lt;--&gt; 20 ## 8 H &lt;--&gt; 1, H &lt;--&gt; 2, H &lt;--&gt; 3, H &lt;--&gt; 4, H &lt;--&gt; 5, H &lt;--&gt; 6, H &lt;--&gt; 7, H &lt;--&gt; 8, H &lt;--&gt; 9, H &lt;--&gt; 10, H &lt;--&gt; 11, H &lt;--&gt; 12, H &lt;--&gt; 13, H &lt;--&gt; 14, H &lt;--&gt; 15, H &lt;--&gt; 16, H &lt;--&gt; 17, H &lt;--&gt; 18, H &lt;--&gt; 19, H &lt;--&gt; 20 ## 9 I &lt;--&gt; 1, I &lt;--&gt; 2, I &lt;--&gt; 3, I &lt;--&gt; 4, I &lt;--&gt; 5, I &lt;--&gt; 6, I &lt;--&gt; 7, I &lt;--&gt; 8, I &lt;--&gt; 9, I &lt;--&gt; 10, I &lt;--&gt; 11, I &lt;--&gt; 12, I &lt;--&gt; 13, I &lt;--&gt; 14, I &lt;--&gt; 15, I &lt;--&gt; 16, I &lt;--&gt; 17, I &lt;--&gt; 18, I &lt;--&gt; 19, I &lt;--&gt; 20 ## 10 J &lt;--&gt; 1, J &lt;--&gt; 2, J &lt;--&gt; 3, J &lt;--&gt; 4, J &lt;--&gt; 5, J &lt;--&gt; 6, J &lt;--&gt; 7, J &lt;--&gt; 8, J &lt;--&gt; 9, J &lt;--&gt; 10, J &lt;--&gt; 11, J &lt;--&gt; 12, J &lt;--&gt; 13, J &lt;--&gt; 14, J &lt;--&gt; 15, J &lt;--&gt; 16, J &lt;--&gt; 17, J &lt;--&gt; 18, J &lt;--&gt; 19, J &lt;--&gt; 20 ## 11 K &lt;--&gt; 1, K &lt;--&gt; 2, K &lt;--&gt; 3, K &lt;--&gt; 4, K &lt;--&gt; 5, K &lt;--&gt; 6, K &lt;--&gt; 7, K &lt;--&gt; 8, K &lt;--&gt; 9, K &lt;--&gt; 10, K &lt;--&gt; 11, K &lt;--&gt; 12, K &lt;--&gt; 13, K &lt;--&gt; 14, K &lt;--&gt; 15, K &lt;--&gt; 16, K &lt;--&gt; 17, K &lt;--&gt; 18, K &lt;--&gt; 19, K &lt;--&gt; 20 ## 12 L &lt;--&gt; 1, L &lt;--&gt; 2, L &lt;--&gt; 3, L &lt;--&gt; 4, L &lt;--&gt; 5, L &lt;--&gt; 6, L &lt;--&gt; 7, L &lt;--&gt; 8, L &lt;--&gt; 9, L &lt;--&gt; 10, L &lt;--&gt; 11, L &lt;--&gt; 12, L &lt;--&gt; 13, L &lt;--&gt; 14, L &lt;--&gt; 15, L &lt;--&gt; 16, L &lt;--&gt; 17, L &lt;--&gt; 18, L &lt;--&gt; 19, L &lt;--&gt; 20 ## 13 M &lt;--&gt; 1, M &lt;--&gt; 2, M &lt;--&gt; 3, M &lt;--&gt; 4, M &lt;--&gt; 5, M &lt;--&gt; 6, M &lt;--&gt; 7, M &lt;--&gt; 8, M &lt;--&gt; 9, M &lt;--&gt; 10, M &lt;--&gt; 11, M &lt;--&gt; 12, M &lt;--&gt; 13, M &lt;--&gt; 14, M &lt;--&gt; 15, M &lt;--&gt; 16, M &lt;--&gt; 17, M &lt;--&gt; 18, M &lt;--&gt; 19, M &lt;--&gt; 20 ## 14 N &lt;--&gt; 1, N &lt;--&gt; 2, N &lt;--&gt; 3, N &lt;--&gt; 4, N &lt;--&gt; 5, N &lt;--&gt; 6, N &lt;--&gt; 7, N &lt;--&gt; 8, N &lt;--&gt; 9, N &lt;--&gt; 10, N &lt;--&gt; 11, N &lt;--&gt; 12, N &lt;--&gt; 13, N &lt;--&gt; 14, N &lt;--&gt; 15, N &lt;--&gt; 16, N &lt;--&gt; 17, N &lt;--&gt; 18, N &lt;--&gt; 19, N &lt;--&gt; 20 ## 15 O &lt;--&gt; 1, O &lt;--&gt; 2, O &lt;--&gt; 3, O &lt;--&gt; 4, O &lt;--&gt; 5, O &lt;--&gt; 6, O &lt;--&gt; 7, O &lt;--&gt; 8, O &lt;--&gt; 9, O &lt;--&gt; 10, O &lt;--&gt; 11, O &lt;--&gt; 12, O &lt;--&gt; 13, O &lt;--&gt; 14, O &lt;--&gt; 15, O &lt;--&gt; 16, O &lt;--&gt; 17, O &lt;--&gt; 18, O &lt;--&gt; 19, O &lt;--&gt; 20 ## 16 P &lt;--&gt; 1, P &lt;--&gt; 2, P &lt;--&gt; 3, P &lt;--&gt; 4, P &lt;--&gt; 5, P &lt;--&gt; 6, P &lt;--&gt; 7, P &lt;--&gt; 8, P &lt;--&gt; 9, P &lt;--&gt; 10, P &lt;--&gt; 11, P &lt;--&gt; 12, P &lt;--&gt; 13, P &lt;--&gt; 14, P &lt;--&gt; 15, P &lt;--&gt; 16, P &lt;--&gt; 17, P &lt;--&gt; 18, P &lt;--&gt; 19, P &lt;--&gt; 20 ## 17 Q &lt;--&gt; 1, Q &lt;--&gt; 2, Q &lt;--&gt; 3, Q &lt;--&gt; 4, Q &lt;--&gt; 5, Q &lt;--&gt; 6, Q &lt;--&gt; 7, Q &lt;--&gt; 8, Q &lt;--&gt; 9, Q &lt;--&gt; 10, Q &lt;--&gt; 11, Q &lt;--&gt; 12, Q &lt;--&gt; 13, Q &lt;--&gt; 14, Q &lt;--&gt; 15, Q &lt;--&gt; 16, Q &lt;--&gt; 17, Q &lt;--&gt; 18, Q &lt;--&gt; 19, Q &lt;--&gt; 20 ## 18 R &lt;--&gt; 1, R &lt;--&gt; 2, R &lt;--&gt; 3, R &lt;--&gt; 4, R &lt;--&gt; 5, R &lt;--&gt; 6, R &lt;--&gt; 7, R &lt;--&gt; 8, R &lt;--&gt; 9, R &lt;--&gt; 10, R &lt;--&gt; 11, R &lt;--&gt; 12, R &lt;--&gt; 13, R &lt;--&gt; 14, R &lt;--&gt; 15, R &lt;--&gt; 16, R &lt;--&gt; 17, R &lt;--&gt; 18, R &lt;--&gt; 19, R &lt;--&gt; 20 ## 19 S &lt;--&gt; 1, S &lt;--&gt; 2, S &lt;--&gt; 3, S &lt;--&gt; 4, S &lt;--&gt; 5, S &lt;--&gt; 6, S &lt;--&gt; 7, S &lt;--&gt; 8, S &lt;--&gt; 9, S &lt;--&gt; 10, S &lt;--&gt; 11, S &lt;--&gt; 12, S &lt;--&gt; 13, S &lt;--&gt; 14, S &lt;--&gt; 15, S &lt;--&gt; 16, S &lt;--&gt; 17, S &lt;--&gt; 18, S &lt;--&gt; 19, S &lt;--&gt; 20 ## 20 T &lt;--&gt; 1, T &lt;--&gt; 2, T &lt;--&gt; 3, T &lt;--&gt; 4, T &lt;--&gt; 5, T &lt;--&gt; 6, T &lt;--&gt; 7, T &lt;--&gt; 8, T &lt;--&gt; 9, T &lt;--&gt; 10, T &lt;--&gt; 11, T &lt;--&gt; 12, T &lt;--&gt; 13, T &lt;--&gt; 14, T &lt;--&gt; 15, T &lt;--&gt; 16, T &lt;--&gt; 17, T &lt;--&gt; 18, T &lt;--&gt; 19, T &lt;--&gt; 20 Ahora cada fila tiene un vector de 20 elementos guardado en la columna resultado 9.4.1 Iterando en la EPH Lo primero que necesitamos es definir un vector o lista sobre el que iterar. Por ejemplo, podemos armar un vector con los path a las bases individuales, con el comando fs::dir_ls bases_individuales_path &lt;- dir_ls(path = &#39;Fuentes/&#39;, regexp= &#39;individual&#39;) bases_individuales_path ## Fuentes/usu_individual_t117.txt Fuentes/usu_individual_t216.txt ## Fuentes/usu_individual_t316.txt Fuentes/usu_individual_t416.txt Luego, como en la función que usamos para leer las bases definimos muchos parametros, nos podemos armar una función wrapper que sólo necesite un parámetro, y que simplifique la escritura del map leer_base_eph &lt;- function(path) { read.table(path,sep=&quot;;&quot;, dec=&quot;,&quot;, header = TRUE, fill = TRUE) %&gt;% select(ANO4,TRIMESTRE,REGION,P21,CH04, CH06) } bases_df &lt;- tibble(bases_individuales_path) %&gt;% mutate(base = map(bases_individuales_path, leer_base_eph)) bases_df ## # A tibble: 4 x 2 ## bases_individuales_path base ## &lt;fs::path&gt; &lt;list&gt; ## 1 Fuentes/usu_individual_t117.txt &lt;df[,6] [58,675 × 6]&gt; ## 2 Fuentes/usu_individual_t216.txt &lt;df[,6] [59,811 × 6]&gt; ## 3 Fuentes/usu_individual_t316.txt &lt;df[,6] [59,550 × 6]&gt; ## 4 Fuentes/usu_individual_t416.txt &lt;df[,6] [58,154 × 6]&gt; El resultado es un DF donde la columna base tiene en cada fila, otro DF con la base de la EPH de ese período. Esto es lo que llamamos un nested DF o dataframe nesteado pa les pibes. Si queremos juntar todo, podemos usar unnest() bases_df &lt;- bases_df %&gt;% unnest() bases_df[1:10,] ## # A tibble: 10 x 7 ## bases_individuales_path ANO4 TRIMESTRE REGION P21 CH04 CH06 ## &lt;fs::path&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 18 ## 2 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 13 ## 3 Fuentes/usu_individual_t117.txt 2017 1 43 0 1 15 ## 4 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 11 ## 5 Fuentes/usu_individual_t117.txt 2017 1 43 0 1 7 ## 6 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 4 ## 7 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 17 ## 8 Fuentes/usu_individual_t117.txt 2017 1 43 0 1 1 ## 9 Fuentes/usu_individual_t117.txt 2017 1 43 1500 1 20 ## 10 Fuentes/usu_individual_t117.txt 2017 1 43 0 2 1 ¿Qué pasa si los DF que tenemos nesteados no tienen la misma cantidad de columnas? Esto mismo lo podemos usar para fragmentar el datastet por alguna variable, con el group_by() bases_df %&gt;% group_by(REGION) %&gt;% nest() ## # A tibble: 6 x 2 ## REGION data ## &lt;int&gt; &lt;list&gt; ## 1 43 &lt;tibble [68,274 × 6]&gt; ## 2 41 &lt;tibble [23,302 × 6]&gt; ## 3 44 &lt;tibble [29,033 × 6]&gt; ## 4 42 &lt;tibble [21,997 × 6]&gt; ## 5 40 &lt;tibble [49,560 × 6]&gt; ## 6 1 &lt;tibble [44,024 × 6]&gt; Así, para cada región tenemos un DF. ¿ De qué sirve todo esto? No todo en la vida es un Dataframe. Hay estucturas de datos que no se pueden normalizar a filas y columnas. En esos casos recurríamos tradicionalmente a los loops. Con MAP podemos tener los elementos agrupados en un sólo objeto y aún conservar sus formas diferentes. 9.5 Ejemplo. Regresión lineal Si bien no nos vamos a meter en el detalle del modelo lineal, es útil usarlo como ejemplo de lo que podemos hacer con MAP. Planteamos el modelo \\[ P21 = \\beta_0 + \\beta_1*CH04 + \\beta_2*CH06 \\] Osea, un modleo que explica el ingreso según sexo y edad lmfit &lt;- lm(P21~factor(CH04)+CH06,data = bases_df) summary(lmfit) ## ## Call: ## lm(formula = P21 ~ factor(CH04) + CH06, data = bases_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8449 -3631 -1938 705 393616 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2599.1101 29.0732 89.40 &lt;2e-16 *** ## factor(CH04)2 -2250.9637 28.3026 -79.53 &lt;2e-16 *** ## CH06 57.3490 0.6347 90.35 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6858 on 236187 degrees of freedom ## Multiple R-squared: 0.05449, Adjusted R-squared: 0.05448 ## F-statistic: 6805 on 2 and 236187 DF, p-value: &lt; 2.2e-16 (al final de la clase podemos charlar sobre los resultados, si hay interés :-) ) De forma Tidy, la librería broom nos da los resultados en un DF. broom::tidy(lmfit) ## # A tibble: 3 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 2599. 29.1 89.4 0 ## 2 factor(CH04)2 -2251. 28.3 -79.5 0 ## 3 CH06 57.3 0.635 90.4 0 Si lo queremos hacer por region 9.5.1 Loopeando resultados &lt;- tibble() for (region in unique(bases_df$REGION)) { data &lt;- bases_df %&gt;% filter(REGION==region) lmfit &lt;- lm(P21~factor(CH04)+CH06,data = data) lmtidy &lt;- broom::tidy(lmfit) lmtidy$region &lt;- region resultados &lt;- bind_rows(resultados,lmtidy) } resultados[1:10,] ## # A tibble: 10 x 6 ## term estimate std.error statistic p.value region ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 (Intercept) 2665. 50.2 53.1 0. 43 ## 2 factor(CH04)2 -2045. 48.6 -42.1 0. 43 ## 3 CH06 41.6 1.06 39.0 0. 43 ## 4 (Intercept) 1808. 69.2 26.1 2.37e-148 41 ## 5 factor(CH04)2 -1808. 67.6 -26.8 2.70e-155 41 ## 6 CH06 55.6 1.58 35.2 7.99e-265 41 ## 7 (Intercept) 3726. 115. 32.3 4.35e-225 44 ## 8 factor(CH04)2 -3337. 112. -29.8 1.23e-192 44 ## 9 CH06 93.4 2.58 36.2 3.12e-280 44 ## 10 (Intercept) 2674. 81.7 32.7 1.28e-229 42 9.5.2 Usando MAP Primero me armo una funcion que me simplifica el codigo fun&lt;-function(porcion,grupo) { broom::tidy(lm(P21~factor(CH04)+CH06,data = porcion))} bases_df_lm &lt;- bases_df %&gt;% group_by(REGION) %&gt;% nest() %&gt;% mutate(lm = map(data,fun)) bases_df_lm ## # A tibble: 6 x 3 ## REGION data lm ## &lt;int&gt; &lt;list&gt; &lt;list&gt; ## 1 43 &lt;tibble [68,274 × 6]&gt; &lt;tibble [3 × 5]&gt; ## 2 41 &lt;tibble [23,302 × 6]&gt; &lt;tibble [3 × 5]&gt; ## 3 44 &lt;tibble [29,033 × 6]&gt; &lt;tibble [3 × 5]&gt; ## 4 42 &lt;tibble [21,997 × 6]&gt; &lt;tibble [3 × 5]&gt; ## 5 40 &lt;tibble [49,560 × 6]&gt; &lt;tibble [3 × 5]&gt; ## 6 1 &lt;tibble [44,024 × 6]&gt; &lt;tibble [3 × 5]&gt; bases_df_lm %&gt;% unnest(lm) %&gt;% top_n(10) ## Selecting by p.value ## # A tibble: 10 x 6 ## REGION term estimate std.error statistic p.value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 41 (Intercept) 1808. 69.2 26.1 2.37e-148 ## 2 41 factor(CH04)2 -1808. 67.6 -26.8 2.70e-155 ## 3 44 (Intercept) 3726. 115. 32.3 4.35e-225 ## 4 44 factor(CH04)2 -3337. 112. -29.8 1.23e-192 ## 5 42 (Intercept) 2674. 81.7 32.7 1.28e-229 ## 6 42 factor(CH04)2 -2250. 79.7 -28.2 1.98e-172 ## 7 42 CH06 52.0 1.75 29.7 2.70e-190 ## 8 40 (Intercept) 1758. 51.3 34.3 2.09e-254 ## 9 1 factor(CH04)2 -2411. 74.3 -32.4 3.61e-228 ## 10 1 CH06 53.1 1.62 32.7 3.34e-232 O incluso más facil, utilizando group_modify (que es un atajo que solo acepta DF) bases_df %&gt;% group_by(REGION) %&gt;% group_modify(fun) %&gt;% top_n(10) ## Selecting by p.value ## # A tibble: 18 x 6 ## # Groups: REGION [6] ## REGION term estimate std.error statistic p.value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 (Intercept) 2993. 77.0 38.9 0. ## 2 1 factor(CH04)2 -2411. 74.3 -32.4 3.61e-228 ## 3 1 CH06 53.1 1.62 32.7 3.34e-232 ## 4 40 (Intercept) 1758. 51.3 34.3 2.09e-254 ## 5 40 factor(CH04)2 -1924. 50.5 -38.1 1.58e-313 ## 6 40 CH06 68.6 1.18 58.1 0. ## 7 41 (Intercept) 1808. 69.2 26.1 2.37e-148 ## 8 41 factor(CH04)2 -1808. 67.6 -26.8 2.70e-155 ## 9 41 CH06 55.6 1.58 35.2 7.99e-265 ## 10 42 (Intercept) 2674. 81.7 32.7 1.28e-229 ## 11 42 factor(CH04)2 -2250. 79.7 -28.2 1.98e-172 ## 12 42 CH06 52.0 1.75 29.7 2.70e-190 ## 13 43 (Intercept) 2665. 50.2 53.1 0. ## 14 43 factor(CH04)2 -2045. 48.6 -42.1 0. ## 15 43 CH06 41.6 1.06 39.0 0. ## 16 44 (Intercept) 3726. 115. 32.3 4.35e-225 ## 17 44 factor(CH04)2 -3337. 112. -29.8 1.23e-192 ## 18 44 CH06 93.4 2.58 36.2 3.12e-280 Pero MAP sirve para operar con cualquier objeto de R. Por ejemplo podemos guardar el objeto S3:lm que es la regresion lineal entrenada. Ese objeto no es ni un vector, ni una lista, ni un DF. No es una estructura de datos, sino que es algo distinto, con propiedades como predict() para predecir, el summary() que vimos, etc. fun&lt;-function(porcion,grupo) { lm(P21~factor(CH04)+CH06,data = porcion)} bases_df %&gt;% group_by(REGION) %&gt;% nest() %&gt;% mutate(lm = map(data,fun)) ## # A tibble: 6 x 3 ## REGION data lm ## &lt;int&gt; &lt;list&gt; &lt;list&gt; ## 1 43 &lt;tibble [68,274 × 6]&gt; &lt;lm&gt; ## 2 41 &lt;tibble [23,302 × 6]&gt; &lt;lm&gt; ## 3 44 &lt;tibble [29,033 × 6]&gt; &lt;lm&gt; ## 4 42 &lt;tibble [21,997 × 6]&gt; &lt;lm&gt; ## 5 40 &lt;tibble [49,560 × 6]&gt; &lt;lm&gt; ## 6 1 &lt;tibble [44,024 × 6]&gt; &lt;lm&gt; 9.5.3 Walk Las funciones Walk Tienen la misma forma que los map, pero se usan cuando lo que queremos iterar no genera una salida, sino que nos interesan los efectos secundarios que generan. map2(ABC_123$Letras,ABC_123$Num,funcion_prueba)[1:3] ## [[1]] ## [1] &quot;A &lt;--&gt; 1&quot; ## ## [[2]] ## [1] &quot;B &lt;--&gt; 2&quot; ## ## [[3]] ## [1] &quot;C &lt;--&gt; 3&quot; walk2(ABC_123$Letras,ABC_123$Num,funcion_prueba) imprimir_salida &lt;- function(x,y){ print(funcion_prueba(x,y)) } walk2(ABC_123$Letras,ABC_123$Num,imprimir_salida) ## [1] &quot;A &lt;--&gt; 1&quot; ## [1] &quot;B &lt;--&gt; 2&quot; ## [1] &quot;C &lt;--&gt; 3&quot; ## [1] &quot;D &lt;--&gt; 4&quot; ## [1] &quot;E &lt;--&gt; 5&quot; ## [1] &quot;F &lt;--&gt; 6&quot; ## [1] &quot;G &lt;--&gt; 7&quot; ## [1] &quot;H &lt;--&gt; 8&quot; ## [1] &quot;I &lt;--&gt; 9&quot; ## [1] &quot;J &lt;--&gt; 10&quot; ## [1] &quot;K &lt;--&gt; 11&quot; ## [1] &quot;L &lt;--&gt; 12&quot; ## [1] &quot;M &lt;--&gt; 13&quot; ## [1] &quot;N &lt;--&gt; 14&quot; ## [1] &quot;O &lt;--&gt; 15&quot; ## [1] &quot;P &lt;--&gt; 16&quot; ## [1] &quot;Q &lt;--&gt; 17&quot; ## [1] &quot;R &lt;--&gt; 18&quot; ## [1] &quot;S &lt;--&gt; 19&quot; ## [1] &quot;T &lt;--&gt; 20&quot; Eso que vemos es el efecto secundario dentro de la función (imprimir) 9.5.4 Discusión. Cuando usar estas herramientas? A lo largo del curso vimos diferentes técnicas para manipulación de datos. En particular, la librería dplyr nos permitía fácilmente modificar y crear nuevas variables, agrupando. Cuando usamos dplyr y cuando usamos purrr. Si trabajamos sobre un DF simple, sin variables anidadas (lo que conocíamos hasta hoy) podemos usar dplyr Si queremos trabajar con DF anidados, con cosas que no son DF, o si el resultado de la operación que vamos a realizar a nivel file es algo distinto a un valor único, nos conviene usar map y purrr Las funciones walk son útiles por ejemplo para escribir archivos en disco de forma iterativa. Algo que no genera una salida 9.6 Lectura y escritura de archivos intermedia R tiene formatos de archivos propios: Rdata RDS 9.6.1 RData x &lt;- 1:15 y &lt;- list(a = 1, b = TRUE, c = &quot;oops&quot;) #Para guardar save(x, y, file = &quot;xy.RData&quot;) #Para leer load(&#39;xy.RData&#39;) Los archivos de tipo RData permiten grabar una imagen de todos los objetos R que querramos. 9.6.2 RDS x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 saveRDS(x, &quot;x.RDS&quot;) Z &lt;- readRDS(&quot;x.RDS&quot;) Z ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Los archivos de tipo RDS no guardan el nombre del objeto, por lo que podemos nombrarlos cuando los cargamos (aconsejable) 9.6.3 SPSS, STATA, SAS A su vez, también R facilmente permite la comunicación con otros softwares estadísticos, o programas destinados al manejo de bases de datos. La librería haven tiene funciones que permiten leer archivos que provienen de otros programas como SPSS, STATA y SAS, entre otros. Los comandos son: read_spss() read_dta() read_sas() 9.6.4 Encoding Tanto a la hora de leer y escribir archivos, como al trabajar un mismo script desde distintas computadoras, debemos ser cuidadosos con el encoding seteado. El encoding es el sistema mediante el cual el sistema interpreta los caracteres del lenguaje natural. Hay muchos encodings diferentes, que interpretan distinto algunos caracteres, como tildes y signos de puntuación. Por ende, si el encoding seteado no es el mismo que el de nuestro script/tabla pueden generarse errores. En medida de lo posible, al escribir nuestros scripts es recomendable evitar estos caracteres. R tiene por default el encoding “ISO-8859-1”, sin embargo el más habitual en América Latina es “UTF-8”. Lectura de archivos : Aglunas de las funciones del tipo read_table, read.xlsx permiten establecer como uno de sus parametros el encoding deseado Encoding utilizado para abrir un script:File -&gt; Reopen with Encoding Encoding default con el que se guardan nuestros Scripts: Tools -&gt; Global Options -&gt; Code -&gt; Saving ## Organización scripts Por último, es aconsejable mantener en todos los script una misma estructura del tipo: Limpiar la memoria rm(list=ls()) Cargar librerías Definir funciones Levantar archivos … procesamiento …. grabar resultados También es útil organizar las partes del script en capítulos. Para eso ### escribimos el título del capitulo encerrado entre tres o más numerales ### 9.7 Ayudas Hay muchas ayudas, propias del programa, o de usuarios, que pueden ser de ayuda. En el programa, para consultar los parámetros de una función, le escribe ?funcion() Rstudio tiene unos machetes muy útiles Rdocumentation stack overflow conviene llegar desde google La clave es aprender la terminología para googlear en ingles las dudas, y prestar atención a que las respuestas sean actuales (R es un lenguaje vivo) 9.8 Ejercicios para practicar Crear una función llamada HolaMundo que imprima el texto “Hola mundo” Crear una función que devuelva la sumatoria de los números enteros comprendidos entre 1 y un parámetro x a definir. Crear una función que calcule la frecuencia expandida por un PONDERA Utilizar dicha función para calcular la frecuencia poblaciónal por Sexo y Región Modificar la función anterior para que devuelva un vector con la frecuencia muestra y la frecuencia poblacional Utilizar la función modificada para calcular la frecuencias frecuencias muestrales y poblacionales por Sexo y Región Levantar la base Individual del 1er trimestre de 2017, de la EPH Guardar la base Individual del 1er trimestre de 2017 como un archivo de extensión .RDS Volver a levantar la base, pero como .RDS y asignarla con el nombre BaseRDS ¿tarda más o menos? basado en https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html↩ "]
]
